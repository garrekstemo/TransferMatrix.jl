var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"These functions are not exported by the TransferMatrix.jl module and can be called using the TransferMatrix. qualifier. Use these methods if you wish to construct a transfer matrix method manually step by step or modify intermediate steps.","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#General-Transfer-Matrix-Method","page":"Internals","title":"General Transfer Matrix Method","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [TransferMatrix]\nPages = [\"general_TMM.jl\", \"layer.jl\", \"matrix_constructors.jl\"]\nPublic = false","category":"page"},{"location":"lib/internals/#TransferMatrix.abs_ratio-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.abs_ratio","text":"Ratio of the absolution squares of two components used to evaluate if a material is birefringent.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.evaluate_birefringence-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.evaluate_birefringence","text":"evaluate_birefringence(Ψ, S, t_modes, r_modes)\n\nFor the four modes (two transmitting and two reflecting), the ratio\n\nbeginaligned\n    C = E_x^2  (E_x^2 + E_y^2) = Ψ_1^2  (Ψ_1^2 + Ψ_3^2)\nendaligned\n\nis evaluated. Recall that the values for the electric field are contained in the eigenvector matrix, Ψ.\n\nIf the layer material is birefringent, there will be anisotropy in the dielectric tensor. If this is the case, the x and y components of the  Poynting vector needs to be analyzed (eqn 15 in Passler et al., 2017):\n\nC = S_x^2  (S_x^2 + S_y^2)\n\nIf there is no birefringence, then the electric field is analyzed. This analysis follows\n\nLi et al., 1988, https://doi.org/10.1364/AO.27.001334\n\nand the use of the Poynting vector is from\n\nPassler et al., 2017, https://doi.org/10.1364/JOSAB.34.002128 Passler et al., 2019, https://doi.org/10.1364/JOSAB.36.003246\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.poynting-NTuple{7, Any}","page":"Internals","title":"TransferMatrix.poynting","text":"poynting(ξ, q_in, q_out, γ_in, γ_out, t_coefs, r_coefs)\n\nCalculate the Poynting vector from wavevectors q, componments of the electric field γ, and transmission and reflection coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.poynting-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.poynting","text":"poynting(Ψ, a)\n\nCalculates the Poynting vector for the structure from Ψ and matrix a.\n\nFrom Berreman, 1972, Ψ is the column matrix:\n\nPsi = \n    beginpmatrix\n        Ex Hy Ey -Hx\n    endpmatrix\n\nfor a right-handed Cartesian coordinate system with the z-axis along the normal to the multilayer structure.\n\nBerreman, 1972, https://doi.org/10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.propagate-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.propagate","text":"propagate(λ, layers, θ, μ)\n\nCalculate the transfer matrix for the entire structure, as well as the Poynting vector for the structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.calculate_q-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.calculate_q","text":"calculate_q(Δ, a)\n\nThe four eigenvalues of q may be obtained from the  4x4 matrix Δ and then eigenvectors may be found for each eigenvalue. Here the eigenvalues must be sorted appropriately to avoid  potentially discontinuous solutions. This extends from the work in\n\nLi et al, 1988, https://doi.org/10.1364/AO.27.001334\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.calculate_γ-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.calculate_γ","text":"calculate_γ(ξ, q, ε, μ)\n\nThe 4 x 3 matrix γ contains vector components that belong  to the electric field calculated such that singularities are identified and removed.\n\nq[1] and q[2] are forward-traveling modes and q[3] and q[4] are backward-traveling modes.\n\nThis is based on the work in Xu, et al., 2000, https://doi.org/10.1103/PhysRevB.61.1740\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.construct_M","page":"Internals","title":"TransferMatrix.construct_M","text":"construct_M(ε, μ, ρ1, ρ2)\n\nConstruct the 6x6 matrix M from the dielectric and permeability tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#TransferMatrix.construct_a-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.construct_a","text":"construct_a(ξ, M)\n\nConstruct the elements of the intermediate 6x6 matrix a in terms of the elements of matrix M (the 6x6 matrix holding the material dielectric and permeability tensors) and propagation vector ξ. This is implemented as described in \n\nBerreman, 1972, https://doi.org/10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.construct_Δ-Tuple{Any, Any, Any}","page":"Internals","title":"TransferMatrix.construct_Δ","text":"construct_Δ(ξ, M, a)\n\nConstruct the reordered matrix Δ in terms of the elements of the two matrices, M and a, and the in-plane reduced wavevector ξ = k_x  k_0. The matrix Δ is involved in the relation\n\n    fracdeltadelta zPsi = fraci omegacDelta Psi\n\nand Δ is the reordered S matrix in Berreman's formulation.\n\nBerreman, 1972, https://doi.org/10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.dynamical_matrix-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.dynamical_matrix","text":"dynamical_matrix(ξ, q, γ, μ)\n\nThe dynamical matrix relating two layers at the interface where matrix A_i for layer i relates the field E_i to the field in the previous layer i - 1 via\n\n    A_i-1E_i-1 = A_iE_i\n\nXu, et al., 2000, https://doi.org/10.1103/PhysRevB.61.1740\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.layer_matrices-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.layer_matrices","text":"layer_matrices(ω, ξ, layer, μ)\n\nCalculate all parameters for a single layer, particularly the propagation matrix and dynamical matrix so that the overall transfer matrix can be calculated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.permeability_tensor-Tuple{Any, Any, Any}","page":"Internals","title":"TransferMatrix.permeability_tensor","text":"permeability_tensor(μ1, μ2, μ3)\n\nThis produces the diagonal permeability tensor,  which is identical to the way we build the dielectric_tensor, and we include this function simply for completeness.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.propagation_matrix-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.propagation_matrix","text":"propagation_matrix(ω, q)\n\nReturns a function that propagates the electromagnetic field a distance z through a material for a frequency ω and wavevector q.\n\n\n\n\n\n","category":"method"},{"location":"guide/quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"If you just want to get started with a transfer matrix calculation and plot the transmittance or reflectance  spectrum, this is the place to start. First install TransferMatrix.jl by typing ] from the Julia REPL to enter package mode, then enter","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"pkg> add TransferMatrix","category":"page"},{"location":"guide/quickstart/#Quarter-wave-mirror","page":"Quick Start","title":"Quarter-wave mirror","text":"","category":"section"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"Let's make a simple quarter-wave mirror, or distributed bragg reflector (DBR). We will do this via alternating layers of titanium dioxide (n = 2.13) and silica (n = 1.46) optimized for a wavelength of 630 nm. We'll make three periods of these two layers and and layer of air. This 4x4 transfer matrix method simultaneously calculates the transmittance and reflectance for s-polarized and p-polarized  radiation. (We are using the powerful plotting library Makie.jl to produce the figures.)","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"using TransferMatrix\nusing CairoMakie\nusing RefractiveIndex\n\nn_air = RefractiveMaterial(\"other\", \"air\", \"Ciddor\")\nn_tio2 = RefractiveMaterial(\"main\", \"TiO2\", \"Sarkar\")\nn_sio2 = RefractiveMaterial(\"main\", \"SiO2\", \"Rodriguez-de_Marcos\")\n\nλ_0 = 0.63  # μm\nt_tio2 = λ_0 / (4 * n_tio2(λ_0))\nt_sio2 = λ_0 / (4 * n_sio2(λ_0))\n\nair = Layer(n_air, 0.1)\ntio2 = Layer(n_tio2, t_tio2)\nsio2 = Layer(n_sio2, t_sio2)\n\nunit = [tio2, sio2]\nperiods = 3\nlayers = [air, repeat(unit, periods)...]\n\nλs = 0.4:0.002:1.0\nRpp = Float64[]\nfor λ in λs\n    Tpp_, Tss_, Rpp_, Rss_ = calculate_tr(λ, layers)\n    push!(Rpp, Rpp_)\nend\n\n\nf, ax, l = lines(λs .* 1e3, Rpp)\nax.xlabel = \"Wavelength (nm)\"\nax.ylabel = \"Reflectance\"\n\nf","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's try a few more periods and plot them all together to see how the reflectance changes with increasing number of layers. Notice that we are adding new layers directly to the structure and not creating a new structure.","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"nperiods = 6\n\nfor i in 1:nperiods\n    push!(layers, tio2)\n    push!(layers, sio2)\n    Rpp = Float64[]\n    if i%3 == 0\n        for λ in λs\n            Tpp_, Tss_, Rpp_, Rss_ = calculate_tr(λ, layers)\n            push!(Rpp, Rpp_)\n        end\n        lines!(ax, λs .* 1e3, Rpp, label = \"$(i + 3) periods\")\n    end\nend\n\naxislegend(ax)\nf","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"These functions and types are to be used for transfer matrix calculation based on the sources used. If you wish to modify any of the steps in the  calculation, refer to the private API.","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Transfer-Matrix-Functions","page":"Public","title":"Transfer Matrix Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [TransferMatrix]\nPages = [\"general_TMM.jl\", \"layer.jl\", \"matrix_constructors.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/#TransferMatrix.angle_resolved-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.angle_resolved","text":"angle_resolved(λs, θs, layers)\n\nCalculate the transmission and reflection at different angles of incidence and wavelengths for a stack of layers.\n\nArguments\n\nλs: Vector of wavelengths.\nθs: Vector of angles of incidence in radians.\nlayers: Vector of Layer objects representing the stack.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.calculate_tr","page":"Public","title":"TransferMatrix.calculate_tr","text":"calculate_tr(λ, layers, θ, μ)\n\nCalculate the transmittance and reflectance spectrum of the structure at a single incidence angle θ. Accurate transmittance must be calculated via the Poynting vector. Reflectance is calculated directly from the transfer matrix elements.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.calculate_tr-Tuple{Any}","page":"Public","title":"TransferMatrix.calculate_tr","text":"calculate_tr(Γ)\n\nCalculate reflectance and transmittance for the total stack. This takes the matrix Γ* in Passler, et al., but for brevity we call it Γ in this function.\n\nThe original formalism is from: Yeh, 1979, https://doi.org/10.1364/JOSA.69.000742\n\nbut the ordering of reflection/transmission coefficients  is modified in Passler, et al. 2017 https://doi.org/10.1364/JOSAB.34.002128\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.calculate_tr-Tuple{TransferMatrix.Poynting}","page":"Public","title":"TransferMatrix.calculate_tr","text":"calculate_tr(S::Poynting)\n\nCalculate transmittance from the Poynting vector struct, which contains incident and transmitted energy for both p-polarized and s-polarized waves.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.electric_field","page":"Public","title":"TransferMatrix.electric_field","text":"electric_field(λ, layers, θ; dz)\n\nCalculate the electric field profile for the entire structure as a function of z for a given incidence angle θ.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.tune_thickness","page":"Public","title":"TransferMatrix.tune_thickness","text":"tune_thickness(λs, ts, layers, t_index, θ=0.0)\n\nTune the thickness of a specific layer in a stack and calculate the transmission and reflection.\n\nArguments\n\nλs: Vector of wavelengths.\nts: Vector of thicknesses.\nlayers: Vector of Layer objects representing the stack.\nt_index: Index of the layer in the stack to tune the thickness of.\nθ: Angle of incidence in radians. Default is 0.0 (normal incidence).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.Layer","page":"Public","title":"TransferMatrix.Layer","text":"Layer(material, thickness)\n\nConstruct a single layer with keywords:\n\nmaterial: refractive material containing dispersion and extinction data (if available)\nthickness: thickness of the layer\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TransferMatrix.dielectric_constant-Tuple{Real, Real}","page":"Public","title":"TransferMatrix.dielectric_constant","text":"dielectric_constant(n_re::Real, n_im::Real)\n\nReturn the complex dielectric function from the real and imaginary parts of the index of refraction.\n\nThe complex index of refraction, given by\n\n    n' = n_re + i * n_im\n\n(in terms of nre and nim), can be used to obtain the frequency-dependent complex dielectric function\n\n    ε_r(ω) = ε' + iε''\n\nvia the relation\n\n    (n_re + i * n_im)^2 = ε' + iε''.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.find_bounds-Tuple{Any}","page":"Public","title":"TransferMatrix.find_bounds","text":"find_bounds(layers)\n\nFind the unitful z coordinate for all layer-layer interfaces in the structure, with the first interface starting at z = 0. (negative z corresponds to positions inside the first layer.)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.refractive_index-Tuple{RefractiveIndex.RefractiveMaterial}","page":"Public","title":"TransferMatrix.refractive_index","text":"refractive_index()\n\nReturn a function that takes a wavelength and gives the real and imaginary parts of the refractive index\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_tensor-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.dielectric_tensor","text":"dielectric_tensor(ε1, ε2, ε3)\n\nReturn the diagonal complex dielectric tensor\n\nvarepsilon = \nbeginpmatrix\n    varepsilon_1  0  0 0  varepsilon_2   0 0  0  varepsilon_3\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Miscellaneous-Optics-Functions","page":"Public","title":"Miscellaneous Optics Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [TransferMatrix]\nPages = [\"optics_functions.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/#TransferMatrix.dbr_reflectivity-NTuple{5, Any}","page":"Public","title":"TransferMatrix.dbr_reflectivity","text":"dbr_reflectivity(no, ns, n1, n2, N)\n\nApproximate the reflectivity of a DBR structure with originating medium with refractive index no, substrate with index ns, and alternating materials with indices n1 and n2 and number of repetitions N. The repeated pair of materials are assumed to have quarter-wave thickness nd = lambda  4, where n is the refractive index, d is the layer thickness, and lambda is the wavelength of the light.\n\nDistributed Bragg reflector\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.fresnel-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.fresnel","text":"fresnel(θ, n1, n2)\n\nCalculate the reflectance for s-polarized and p-polarized light given the incidence angle θ and indices of refraction  of two media n1 and n2 at a plane interface.\n\nFresnel equations\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.stopband-Tuple{Any, Any}","page":"Public","title":"TransferMatrix.stopband","text":"stopband(n1, n2)\n\nCalculate the frequency bandwidth Δf of the photonic stopband for a distributed bragg reflector (DBR) with two alternating materials of refractive indices n1 and n2.\n\n    fracDelta f_0f_0 = frac4pi arcsin left( fracn_2 - n_1n_2 + n_1 right)\n\nDistributed Bragg reflector\n\n\n\n\n\n","category":"method"},{"location":"bibliography/#References","page":"References","title":"References","text":"","category":"section"},{"location":"bibliography/","page":"References","title":"References","text":"All references used for writing TransferMatrix.jl.","category":"page"},{"location":"bibliography/","page":"References","title":"References","text":"[1] N. C. Passler, M. Jeannin, and A. Paarmann, Layer-Resolved Absorption of Light in Arbitrarily Anisotropic Heterostructures, Phys. Rev. B 101, 165425 (2020). \n[2] B. Garibello, N. Avilán, J. A. Galvis, and C. A. Herreño-Fierro, On the Singularity of the Yeh 4 × 4 Transfer Matrix Formalism, Journal of Modern Optics 67, 832 (2020). \n[3] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures: Erratum, J. Opt. Soc. Am. B 36, 3246 (2019). \n[4] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures, J. Opt. Soc. Am. B 34, 2128 (2017). \n[5] P. Yeh, Optical Waves in Layered Media (Wiley, 2005). \n[6] W. Xu, L. T. Wood, and T. D. Golding, Optical Degeneracies in Anisotropic Layered Media: Treatment of Singularities in a 4×4 Matrix Formalism, Phys. Rev. B 61, 1740 (2000). \n[7] Z.-M. Li, B. T. Sullivan, and R. R. Parsons, Use of the 4 × 4 Matrix Method in the Optics of Multilayer Magnetooptic Recording Media, Appl. Opt., AO 27, 1334 (1988). \n[8] P. Yeh, Electromagnetic Propagation in Birefringent Layered Media, J. Opt. Soc. Am. 69, 742 (1979). \n[9] D. W. Berreman, Optics in Stratified and Anisotropic Media: 4×4-Matrix Formulation, J. Opt. Soc. Am. 62, 502 (1972).","category":"page"},{"location":"#TransferMatrix.jl","page":"Introduction","title":"TransferMatrix.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TransferMatrix.jl provides a general 4x4 transfer matrix method for optical waves propagating in layered media implemented in Julia. The core is an electrodynamics simulation based on a general 4x4 transfer matrix method developed by Passler, et al. Recent corrections and improvements are incorporated to deal with singularities and numerical instabilities for some types of multi-layered structures. Sources are cited both in the documentation and docstrings where appropriate. A comprehensive bibliography is also available as part of the documentation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are a lot of transfer matrix programs out there. Many are proprietary and some are part of graduate theses. The problem with the proprietary ones are that the source code cannot be examined  nor modified (and are not free). The problem with programs  written for papers are that they are rarely maintained, are not well documented, are not well tested, and are poorly organized. This makes it very difficult to use them. TransferMatrix.jl  solves these problems and provides the first generalized 4x4 transfer matrix algorithm available for Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<div style=\"text-align: center;\">\n<img src=\"assets/polariton_dispersion.png\" alt=\"polariton dispersion\", width=\"100%\"/>\n</div>","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported types and functions are considered part of the public API. All of these objects are documented in this manual. If not, please open an issue. The advanced user is encouraged, however, to access the guts of TransferMatrix.jl and modify portions to achieve a desired outcome or test a different approach to the algorithm. This implementation is as modular as possible to maximize flexibility; each function is as small as possible so that the user may easily change any step along the way in calculating the transfer matrix, reflection or transmission spectra, electric field profile, etc.","category":"page"},{"location":"#Issues-and-contributions","page":"Introduction","title":"Issues and contributions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you spot any errors or improvements to make, please open an issue and if you want to contribute consider making a pull request.","category":"page"},{"location":"guide/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"guide/tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"TransferMatrix.jl is a part of Julia's general registry and the source code can be found at https://github.com/garrekstemo/TransferMatrix.jl. From the Julia REPL, enter the package manager mode mode by typing ]. Then just enter the following to install the package:","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"pkg> add TransferMatrix","category":"page"},{"location":"guide/tutorial/#A-simple-calculation","page":"Tutorial","title":"A simple calculation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"To get up and running, let's build a simple two-layer structure of air and glass and calculate the reflectance and transmittance to visualize the Brewster angle for p-polarized light. We fix the wavelength of incident light and vary the angle of incidence.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by making a Layer of air and a Layer of glass. We'll do this for  a wavelength of 1 μm. Since there are only two layers and the transfer matrix method treats the first and last layers as semi-infinite, there is no need to provide a thickness for our glass and air layers. From the examples below, you can see that there are fields for","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"the material\nthe layer thickness","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The material is a RefractiveMaterial from the RefractiveIndex.jl package. You can also initize a Layer with data for the refractive index and extinction coefficient.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransferMatrix\nusing RefractiveIndex\n\nn_air = RefractiveMaterial(\"other\", \"air\", \"Ciddor\")\nn_glass = RefractiveMaterial(\"glass\", \"soda-lime\", \"Rubin-clear\")[1]\nair = Layer(n_air, 0.1)\nglass = Layer(n_glass, 0.1)\nlayers = [air, glass];","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have our glass and air layers, we can iterate over the angles of incidence and compute the reflectance and transmittance for light of wavelength 1 μm.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"λ = 1.0\nθs = 0.0:1:85.0\nresult = angle_resolved([λ], deg2rad.(θs), layers);","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's now plot the result using the Makie.jl data visualization package.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\nbrewster = atan(n_glass(λ)) * 180 / π\n\nf = Figure()\nax = Axis(f[1, 1], xlabel = \"Incidence Angle (°)\", ylabel = \"Reflectance / Transmittance\")\nlines!(θs, result.Tss[:, 1], label = \"Ts\", color = :firebrick3)\nlines!(θs, result.Tpp[:, 1], label = \"Tp\", color = :orangered3)\nlines!(θs, result.Rss[:, 1], label = \"Rs\", color = :dodgerblue4)\nlines!(θs, result.Rpp[:, 1], label = \"Rp\", color = :dodgerblue1)\nvlines!(brewster, color = :black, linestyle = :dash)\ntext!(35, 0.6, text = \"Brewster angle\\n(Rp = 0)\")\n\naxislegend(ax)\nf","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can see that the result of the angle-resolved calculation has four solutions: the s-wave and p-wave for both the reflected and transmitted waves. And we see that the Brewster angle is arctanleft( n_textglass n_textair right) approx 56^circ, as expected. Simultaneous calculation of s- and p-polarized incident waves is a feature of the  general 4x4 transfer matrix method being used. The angle_resolved function will also loop through all wavelengths so that you can plot a color plot of wavelength and angle versus transmittance (or reflectance).","category":"page"},{"location":"guide/tutorial/#A-simple-multi-layered-structure","page":"Tutorial","title":"A simple multi-layered structure","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we can make Layers, we can put them together to calculate  the transfer matrix for a multi-layered structure and plot the reflectance and transmittance spectra. An important structure in optics is the Fabry-Pérot etalon, made with two parallel planar mirrors with a gap between them. If we set the optical path length to be an integer multiple of half the wavelength, we get constructive interference and a resonance in the transmittance spectrum. In the frequency domain, the cavity modes are evenly spaced by the free spectral range (FSR). We will scan in the mid infrared between 4 and 6 μm and use data generated via the Lorentz-Drude model for each 10 nm-thick gold mirror. (Note that we stay in units of micrometers for the wavelength.)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"caf2 = RefractiveMaterial(\"main\", \"CaF2\", \"Malitson\")\nau = RefractiveMaterial(\"main\", \"Au\", \"Rakic-LD\")\nair = RefractiveMaterial(\"other\", \"air\", \"Ciddor\")\n\nλ_0 = 5.0\nt_middle = λ_0 / 2\nair = Layer(air, t_middle)\nau = Layer(au, 0.01)\nlayers = [air, au, air, au, air];\n\nλs = range(2.0, 6.0, length = 500)\nfrequencies = 10^4 ./ λs\n\nTp = Float64[]\nTs = Float64[]\nRp = Float64[]\nRs = Float64[]\nfor λ in λs\n    Tp_, Ts_, Rp_, Rs_ = calculate_tr(λ, layers)\n    push!(Tp, Tp_)\n    push!(Ts, Ts_)\n    push!(Rp, Rp_)\n    push!(Rs, Rs_)\nend\n\nf, ax, l = lines(frequencies, Ts)\nax.xlabel = \"Frequency (cm⁻¹)\"\nax.ylabel = \"Transmittance\"\nf","category":"page"},{"location":"guide/tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The wavelength-dependent electric field is the cavity is provided by the electric_field function. We can calculate the electric field at the first peak in the above plot using","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"λ_min = findfirst(λs .> 4.9)\nλ_max = findfirst(λs .> 5.5)\npeak = findmax(Ts[λ_min:λ_max])[2] + λ_min - 1\nλ = λs[peak]\n\nfield = electric_field(λ, layers)\n\nf, ax, l = lines(field.z .* 1e3, real(field.p[1, :]))\nvlines!(field.boundaries[1], color = :black, linestyle = :dash)\nvlines!(field.boundaries[end] .* 1e3, color = :black, linestyle = :dash)\nf","category":"page"},{"location":"guide/tutorial/#User-generated-refractive-index-data","page":"Tutorial","title":"User-generated refractive index data","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"A convenience function is available to generate a Layer with user-generated refractive index data. For example, if we want to make an absorbing layer modeled on a Lorentzian function, we would","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Generate the dielectric function for the absorbing material.\nCalculate the refractive index and extinction coefficient.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n   varepsilon_r(omega) = n_infty^2 + fracA (omega_0^2 - omega^2)(omega^2 - omega_0^2)^2 + (Gamma omega)^2 \n\n   varepsilon_i(omega) = fracA Gamma omega(omega^2 - omega_0^2)^2 + (Gamma omega)^2 \n\n   n(omega) = sqrtfracvarepsilon_r + sqrtvarepsilon_r^2 + varepsilon_i^22 \n\n   k(omega) = sqrtfrac-varepsilon_r + sqrtvarepsilon_r^2 + varepsilon_i^22 \nendaligned","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"where A is the amplitude, omega_0 is the resonant frequency, Gamma is phenomenological damping, and n_infty is the background refractive index. Then this data, along with the wavelengths and thickness of the layer, can be used to create a Layer object. Under the hood, this data is converted into an interpolation function that, when given a wavelength, will return the complex refractive index. (Extrapolation is not supported right now.)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"function dielectric_real(ω, p)\n    A, ω_0, Γ = p\n    return @. A * (ω_0^2 - ω^2) / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)\nend\n\nfunction dielectric_imag(ω, p)\n    A, ω_0, Γ = p\n    return @. A * Γ * ω / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)\nend\n\n# absorbing material\nλ_0 = 5.0\nλs = range(4.8, 5.2, length = 200)\nfrequencies = 10^4 ./ λs\nn_bg = 1.4\nA_0 = 3000.0\nω_0 = 10^4 / λ_0  # cm^-1\nΓ_0 = 5\np0 = [A_0, ω_0, Γ_0]\nε1 = dielectric_real(frequencies, p0) .+ n_bg^2\nε2 = dielectric_imag(frequencies, p0)\nn_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) + ε1) / 2)\nk_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) - ε1) / 2)\n\nabsorber = Layer(λs, n_medium, k_medium, t_cav)\nabsorber.dispersion(4.9)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"A complete example calculating dispersion of a polaritonic system is provided in the examples folder of the package source code.","category":"page"},{"location":"guide/tutorial/#Thickness-dependent-calculations","page":"Tutorial","title":"Thickness-dependent calculations","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Instead of angle-resolved, you might want to vary the thickness of a particular layer. A convenience function, tune_thickness is provided to do this. It takes a list of wavelengths, a list of thicknesses, the layers, and the index of the layer to vary. For example, if you want to vary the 14th layer in the layers array, you might do the following:","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"tune_thickness(λs, thicknesses, layers, 14)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"A complete example using this is provided in the examples folder of the package source code.","category":"page"}]
}
