var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"These functions are not exported by the TransferMatrix.jl module and can be called using the TransferMatrix. qualifier. Use these methods if you wish to construct a transfer matrix method manually step by step or modify intermediate steps.","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Transfer-Matrix-Functions","page":"Internals","title":"Transfer Matrix Functions","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [TransferMatrix]\nPages = [\"core.jl\"]\nPublic = false","category":"page"},{"location":"lib/internals/#TransferMatrix.abs_ratio-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.abs_ratio","text":"Ratio of the absolution squares of two components used to evaluate if a material is birefringent.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.calculate_q-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.calculate_q","text":"calculate_q(Δ, a)\n\nThe four eigenvalues of q may be obtained from the  4x4 matrix Δ and then eigenvectors may be found for each eigenvalue. Here the eigenvalues must be sorted appropriately to avoid  potentially discontinuous solutions. This extends from the work in\n\nLi et al, 1988, DOI: 10.1364/AO.27.001334\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.calculate_Γ_S","page":"Internals","title":"TransferMatrix.calculate_Γ_S","text":"calculate_Γ_S(s::Structure, θ=0.0)\n\nCalculate the total structure transfer matrix Γ and the Poynting vector S for all input frequencies ω, returning the TransferMatrixResult type, which contains all transfer matrices, Poynting vectors, and ξ.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#TransferMatrix.calculate_γ-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.calculate_γ","text":"calculate_γ(ξ, q, ε, μ)\n\nThe 4 x 3 matrix γ contains vector components that belong  to the electric field calculated such that singularities are identified and removed.\n\nq[1] and q[2] are forward-traveling modes and q[3] and q[4] are backward-traveling modes.\n\nThis is based on the work in:\n\nXu et al. Optical degeneracies in anisotropic layered media: Treatment of singularities in a 4x4 matrix formalism, 2000. DOI: 10.1103/PhysRevB.61.1740\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.construct_a-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.construct_a","text":"construct_a(ξ, M)\n\nConstruct the elements of the intermediate 6x6 matrix a in terms of the elements of matrix M (the 6x6 matrix holding the material dielectric and permeability tensors) and propagation vector ξ. This is implemented as described in \n\nBerreman, 1972, DOI: 10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.construct_Δ-Tuple{Any, Any, Any}","page":"Internals","title":"TransferMatrix.construct_Δ","text":"construct_Δ(ξ, M, a)\n\nConstruct the reordered matrix Δ in terms of the elements of the two matrices, M and a, and the in-plane reduced wavevector ξ = k_x  k_0. The matrix Δ is involved in the relation\n\nfracdeltadelta zPsi = fraci omegacDelta Psi\n\nand Δ is the reordered S matrix in Berreman's formulation.\n\nBerreman, 1972, DOI: 10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.dynamical_matrix-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.dynamical_matrix","text":"dynamical_matrix(ξ, q, γ, μ)\n\nThe dynamical matrix relating two layers at the interface where matrix A_i for layer i relates the field E_i to the field in the previous layer i - 1 via\n\nA_i-1E_i-1 = A_iE_i\n\nXu et al., 2000, DOI: 10.1103/PhysRevB.61.1740\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.evaluate_birefringence-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.evaluate_birefringence","text":"evaluate_birefringence(Ψ, S, t_modes, r_modes)\n\nFor the four modes (two transmitting and two reflecting), the ratio\n\nbeginaligned\n    C = E_x^2  (E_x^2 + E_y^2) = Ψ_1^2  (Ψ_1^2 + Ψ_3^2)\nendaligned\n\nis evaluated. Recall that the values for the electric field are contained in the eigenvector matrix, Ψ.\n\nIf the layer material is birefringent, there will be anisotropy in the dielectric tensor. If this is the case, the x and y components of the  Poynting vector needs to be analyzed (eqn 15 in Passler et al., 2017):\n\nC = S_x^2  (S_x^2 + S_y^2)\n\nIf there is no birefringence, then the electric field is analyzed. This analysis follows\n\nLi et al., 1988, DOI: 10.1364/AO.27.001334\n\nand the use of the Poynting vector is from\n\nPassler et al., 2017, DOI: 10.1364/JOSAB.34.002128\n\nand\n\nPassler et al., 2019, DOI: 10.1364/JOSAB.36.003246\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.interp_data-Tuple{Layer, Any}","page":"Internals","title":"TransferMatrix.interp_data","text":"interp_data(layer::Layer, λs)\n\nGiven a new set of wavelengths (the Vector, λs), interpolate the  complex refractive index values for the input Layer and return a new Layer with the new λ, n, and κ. The new wavelengths must not extend beyond the  domain of the existing wavelengths in the Layer (i.e. no extrapolation).\n\nHere we use LinearInterpolation from the package DataInterpolations.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.layer_params-NTuple{5, Any}","page":"Internals","title":"TransferMatrix.layer_params","text":"layer_params(ω, ξ, n, μ, d)\n\nCalculate all parameters for a single layer, particularly the propagation matrix and dynamical matrix so that the overall transfer matrix can be calculated.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.permeability_tensor-Tuple{Any, Any, Any}","page":"Internals","title":"TransferMatrix.permeability_tensor","text":"permeability_tensor(μ1, μ2, μ3)\n\nThis produces the diagonal permeability tensor,  which is identical to the way we build the dielectric_tensor, and we include this function simply for completeness.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.poynting-NTuple{7, Any}","page":"Internals","title":"TransferMatrix.poynting","text":"poynting(ξ, q_in, q_out, γ_in, γ_out, t_coefs, r_coefs)\n\nCalculate the Poynting vector from wavevectors q, componments of the electric field γ, and transmission and reflection coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.poynting-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.poynting","text":"poynting(Ψ, a)\n\nCalculates the Poynting vector for the structure from Ψ and matrix a.\n\nFrom Berreman, 1972, Ψ is the column matrix:\n\nPsi = \n    beginpmatrix\n        Ex Hy Ey -Hx\n    endpmatrix\n\nfor a right-handed Cartesian coordinate system with the z-axis along the normal to the multilayer structure.\n\nBerreman, 1972, DOI: 10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.tr_from_poynting-Tuple{Poynting}","page":"Internals","title":"TransferMatrix.tr_from_poynting","text":"tr_from_poynting(S::Poynting)\n\nCalculate transmittance from the Poynting vector struct, which contains incident and transmitted energy for both p-polarized and s-polarized waves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.tr_from_poynting-Tuple{Vector{Poynting}}","page":"Internals","title":"TransferMatrix.tr_from_poynting","text":"tr_from_poynting(Ss::Vector{Poynting})\n\nCalculate transmission and reflection spectra from a Vector of Poynting types.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.tr_from_Γ-Tuple{Matrix}","page":"Internals","title":"TransferMatrix.tr_from_Γ","text":"tr_from_Γ(Γ::Matrix)\n\nCalculate reflectance and transmittance for the total structure. This takes the matrix Γ*, but for brevity we call it Γ in this function.\n\nThis follows the formalism in:\n\nYeh, Electromagnetic propagation in birefringent layered media, 1979, DOI: 10.1364/JOSA.69.000742\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.tr_from_Γ-Tuple{Vector}","page":"Internals","title":"TransferMatrix.tr_from_Γ","text":"tr_from_Γ(Γs::Vector)\n\nCalculate reflectance and transmittance for the total structure for each Γ in the Vector of Γs.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.transfermatrix-NTuple{6, Any}","page":"Internals","title":"TransferMatrix.transfermatrix","text":"transfermatrix(ω, ξ, q, γ, μ, d)\n\nCalcuate the transfer matrix from the dynamical (interface) matrix and propagation matrix for one layer.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [TransferMatrix]\nPages = [\"types.jl\"]\nPublic = false","category":"page"},{"location":"lib/internals/#Data-Read/Write-Functions","page":"Internals","title":"Data Read/Write Functions","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [TransferMatrix]\nPages = [\"dataio.jl\"]\nPublic = false","category":"page"},{"location":"lib/internals/#TransferMatrix.yaml_example-Tuple{}","page":"Internals","title":"TransferMatrix.yaml_example","text":"yaml_example()\n\nGenerate an example input parameter yaml file.\n\n\n\n\n\n","category":"method"},{"location":"guide/quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"If you just want to get started with a transfer matrix calculation and plot the transmittance or reflectance  spectrum, this is the place to start. First make sure to install TransferMatrix.jl by typing ] from the Julia REPL to enter Pkg mode, then run","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"pkg> add https://github.com/garrekstemo/TransferMatrix.jl.git","category":"page"},{"location":"guide/quickstart/#Quarter-wave-mirror","page":"Quick Start","title":"Quarter-wave mirror","text":"","category":"section"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"Let's make a simple quarter-wave mirror, or distributed bragg reflector (DBR). We will do this via alternating layers of titanium dioxide (n = 2.13) and silica (n = 1.46) optimized for a wavelength of 630 nm. We'll make three periods of these two layers and and layer of air. This 4x4 transfer matrix method simultaneously calculates the transmittance and reflectance for s-polarized and p-polarized  radiation. (We are using the powerful plotting library Makie.jl to produce the figures.)","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"using Pkg\nPkg.add(url=\"https://github.com/garrekstemo/TransferMatrix.jl.git\")\nPkg.add(\"CairoMakie\")","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"using TransferMatrix\nusing CairoMakie\n\nλs = collect(range(0.4, 1.0, length = 1000)) .* 1e-6\nn_tio2 = fill(2.13, length(λs))\nn_sio2 = fill(1.46, length(λs))\n\nair = Layer(\"Air\", 0.5e-6, λs, fill(1.0, length(λs)), zeros(length(λs)))\ntio2 = Layer(\"TiO2\", 0.074e-6, λs, n_tio2, zeros(length(λs)))\nsio2 = Layer(\"SiO2\", 0.108e-6, λs, n_sio2, zeros(length(λs)))\n\nlayers = [air, tio2, sio2, tio2, sio2, tio2, sio2]\n\ns = Structure(layers, λs, [0.0])\nTp, Ts, Rp, Rs = calculate_tr(s)\n\nfig, ax, l = lines(λs .* 1e9, Rp, label = \"3 periods\")\n\nax.xlabel = \"Wavelength (nm)\"\nax.ylabel = \"Reflectance\"\n\nfig","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's try a few more periods and plot them all together to see how the reflectance changes with increasing number of layers. Notice that we are adding new layers directly to the structure and not creating a new structure.","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"nperiods = 6\n\nfor i in 1:nperiods\n    push!(s.layers, tio2)\n    push!(s.layers, sio2)\n    if i%3 == 0\n        Tp, Ts, Rp, Rs = calculate_tr(s)\n        lines!(ax, λs .* 1e9, Rp, label = \"$(i + 3) periods\")\n    end\nend\n\naxislegend(ax)\nfig","category":"page"},{"location":"guide/quickstart/","page":"Quick Start","title":"Quick Start","text":"You can see that it's quite simple to make a structure and modify the layers. Note that while an individual Layer is immutable, you can modify the properties of a Structure.","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"These functions and types are to be used for transfer matrix calculation based on the sources used. If you wish to modify any of the steps in the  calculation, refer to the private API.","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Transfer-Matrix-Functions","page":"Public","title":"Transfer Matrix Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [TransferMatrix]\nPages = [\"core.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/#TransferMatrix.angle_resolved-Tuple{Structure}","page":"Public","title":"TransferMatrix.angle_resolved","text":"angle_resolved(s::Structure)\n\nIterate through each angle provided in the structure to find the reflectance and transmittance spectra from the calculated transfer matrices and Poynting vectors.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.calculate_tr","page":"Public","title":"TransferMatrix.calculate_tr","text":"calculate_tr(s::Structure, θ=0.0)\n\nCalculate the transmittance and reflectance spectrum of the structure at a single incidence angle θ. Accurate transmittance must be calculated via the Poynting vector. Reflectance is calculated directly from the transfer matrix elements.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.dielectric_constant-Tuple{Complex}","page":"Public","title":"TransferMatrix.dielectric_constant","text":"dielectric_constant(n::Complex)\n\nReturn the complex dielectric function from the complex index of refraction.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_constant-Tuple{Layer}","page":"Public","title":"TransferMatrix.dielectric_constant","text":"dielectric_constant(layer::Layer)\n\nReturn a complex dielectric function from the index of refraction in a Layer` type.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_constant-Tuple{Real, Real}","page":"Public","title":"TransferMatrix.dielectric_constant","text":"dielectric_constant(n::Real, κ::Real)\n\nReturn the complex dielectric function from the real and imaginary parts of the index of refraction.\n\nThe complex index of refraction, given by\n\n    n' = n + iκ\n\n(in terms of n and κ), can be used to obtain the frequency-dependent complex dielectric function\n\n    ε_r(ω) = ε' + iε''\n\nvia the relation\n\n    (n + iκ)^2 = ε' + iε''.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_tensor-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.dielectric_tensor","text":"dielectric_tensor(ε1, ε2, ε3)\n\nReturn the diagonal complex dielectric tensor\n\nvarepsilon = \nbeginpmatrix\n    varepsilon_1  0  0 \n    0  varepsilon_2   0 \n    0  0  varepsilon_3\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_tensor-Tuple{Layer}","page":"Public","title":"TransferMatrix.dielectric_tensor","text":"dielectric_tensor(layer::Layer)\n\nThis version of dielectric_tensor takes a Layer type and makes a simple tensor by repeating the dielectric constant on the diagonals for all of the refractive index data stored in the Layer.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.electric_field","page":"Public","title":"TransferMatrix.electric_field","text":"electric_field(s::Structure, λ, θ; numpoints)\n\nCalculate the electric field profile for the entire structure as a function of z for a given incidence angle θ.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.find_layerbounds-Tuple{Structure}","page":"Public","title":"TransferMatrix.find_layerbounds","text":"find_layerbounds(s::Structure)\n\nFind the unitful z coordinate for all layer-layer interfaces in the structure, with the first interface starting at z = 0. (negative z corresponds to positions inside the first layer.)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.initialize-Tuple{Structure, Any}","page":"Public","title":"TransferMatrix.initialize","text":"initialize(structure::Structure, λs)\n\nInitializing a Structure interpolates the wavelength-dependent refractive index data using the given λs Vector for all Layers in the Structure, returning a new structure with the interpolated data.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.printstruct","page":"Public","title":"TransferMatrix.printstruct","text":"printstruct(s::Structure, unit=1e9)\n\nPrint each layer and its thickness in a somewhat  visually useful way. Change the default unit multiplier to switch from nanometers to micrometers. This does not affect any calculations, only what is printed to the command line when using printstruct.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.propagation_matrix-Tuple{Any, Any}","page":"Public","title":"TransferMatrix.propagation_matrix","text":"propagation_matrix(ω, q)\n\nReturns a function that propagates the electromagnetic field a distance z through a material for a frequency ω and wavevector q.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Types","page":"Public","title":"Types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [TransferMatrix]\nPages = [\"types.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/#TransferMatrix.Layer","page":"Public","title":"TransferMatrix.Layer","text":"Layer(material::String, thickness::Float64, λ::Vector{Float64}, n::Vector{Float64}, κ::Vector{Float64})\n\nA Layer stores information about a single layer, including its material name, thickness, a list of electric field wavelengths, and the real and imaginary parts of the refractive index associated with these wavelengths.\n\nInitializing a Layer with no arguments makes a 1 μm thick layer of Air.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TransferMatrix.Structure","page":"Public","title":"TransferMatrix.Structure","text":"Structure\n\nThe Structure is a mutable type that stores a Vector of Layer types, along with a list of field wavelengths and incident angles to calculate on.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Data-Read/Write-Functions","page":"Public","title":"Data Read/Write Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [TransferMatrix]\nPages = [\"dataio.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/#TransferMatrix.load_from_yaml","page":"Public","title":"TransferMatrix.load_from_yaml","text":"read_yaml(file::String)\n\nRead a yaml file with Structure parameters to perform transfer matrix calculations.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#TransferMatrix.read_refractive-Tuple{String, String, Any}","page":"Public","title":"TransferMatrix.read_refractive","text":"read_refractive(f::String, material::String, thickness; div=1.0, freq=false)\n\nReads a csv file from the database website refractiveindex.info containing  a wavelength column in units of micrometers, and two refractive index columns: one for the real part and the other for the imaginary part.\n\nThe header names are:\n\n\"Wavelength, μm\", \"n\", \"k\"\n\nNote that if you put a file in the refractive_index_data folder, then this function can automatically find it if you simply put the file name (with .csv extension) in the refractive_filename field in the yaml file. If you put the file somewhere else, you must provide the full path to that file (or relative path).\n\nFor some reason, the wavelength column cannot be normalized (so as to be a valid Julia identifier) using normalizednames = true in CSV.File, so the header is skipped.\n\n\n\n\n\n","category":"method"},{"location":"bibliography/#References","page":"References","title":"References","text":"","category":"section"},{"location":"bibliography/","page":"References","title":"References","text":"All references used for writing TransferMatrix.jl.","category":"page"},{"location":"bibliography/","page":"References","title":"References","text":"[1] N. C. Passler, M. Jeannin, and A. Paarmann, Layer-Resolved Absorption of Light in Arbitrarily Anisotropic Heterostructures, Phys. Rev. B 101, 165425 (2020). \n[2] B. Garibello, N. Avilán, J. A. Galvis, and C. A. Herreño-Fierro, On the Singularity of the Yeh 4 × 4 Transfer Matrix Formalism, Journal of Modern Optics 67, 832 (2020). \n[3] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures: Erratum, J. Opt. Soc. Am. B 36, 3246 (2019). \n[4] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures, J. Opt. Soc. Am. B 34, 2128 (2017). \n[5] P. Yeh, Optical Waves in Layered Media (Wiley, 2005). \n[6] W. Xu, L. T. Wood, and T. D. Golding, Optical Degeneracies in Anisotropic Layered Media: Treatment of Singularities in a 4×4 Matrix Formalism, Phys. Rev. B 61, 1740 (2000). \n[7] Z.-M. Li, B. T. Sullivan, and R. R. Parsons, Use of the 4 × 4 Matrix Method in the Optics of Multilayer Magnetooptic Recording Media, Appl. Opt., AO 27, 1334 (1988). \n[8] P. Yeh, Electromagnetic Propagation in Birefringent Layered Media, J. Opt. Soc. Am. 69, 742 (1979). \n[9] D. W. Berreman, Optics in Stratified and Anisotropic Media: 4×4-Matrix Formulation, J. Opt. Soc. Am. 62, 502 (1972).","category":"page"},{"location":"#TransferMatrix.jl","page":"Introduction","title":"TransferMatrix.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TransferMatrix.jl provides a general 4x4 transfer matrix method for optical waves propagating in layered media implemented in Julia. The core is an electrodynamics simulation based on Pochi Yeh's 4x4 transfer matrix method. Recent corrections and improvements are incorporated to deal with singularities and numerical instabilities for some types of multi-layered structures. The algorithms implemented are based on the efforts of others and sources are cited both in the documentation and docstrings where appropriate. A comprehensive bibliography is also available as part of the documentation.","category":"page"},{"location":"#Why-make-another-transfer-matrix-program?","page":"Introduction","title":"Why make another transfer matrix program?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are a lot of transfer matrix programs out there. Many are proprietary and some are part of graduate theses and papers. The problem with the proprietary ones are that the source code cannot be examined  nor modified (and are not free). The problem with programs  written for papers are that they are rarely maintained, are not well documented, are not well tested, and are poorly organized. This makes it very difficult to use them. TransferMatrix.jl  solves these problems and provides the first generalized 4x4 transfer matrix algorithm available for Julia.","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. can be used without the TransferMatrix. qualifier after loading the TransferMatrix.jl package with using TransferMatrix) types and functions are considered part of the public API of the TransferMatrix.jl package. All of these objects are documented in this manual. If not, please open an issue. The advanced user is encouraged, however, to access the guts of TransferMatrix.jl and modify portions to achieve a desired outcome or test  a different approach to the algorithm. This implementation is as modular as possible to maximize flexibility; each function is as small as possible so that the user may easily change any step along the way in calculating the transfer matrix, reflection or transmission spectra, electric field profile, etc.","category":"page"},{"location":"#Issues-and-contributions","page":"Introduction","title":"Issues and contributions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you spot any errors or improvements to make, please open an issue and if you want to contribute consider making a pull request.","category":"page"},{"location":"guide/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"guide/tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"TransferMatrix.jl is not a part of Julia's general registry, but can be found at https://github.com/garrekstemo/TransferMatrix.jl. Julia makes it easy to  install unregistered packages. From the Julia REPL, enter the Pkg REPL (package manager) mode by typing ] and then use add to add the GitHub URL to TransferMatrix.jl.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"pkg> add https://github.com/garrekstemo/TransferMatrix.jl","category":"page"},{"location":"guide/tutorial/#A-simple-calculation","page":"Tutorial","title":"A simple calculation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"To get you up and running, let's build a simple two-layer structure of air and glass and calculate the reflectance and transmittance to visualize the Brewster angle for p-polarized light. We fix the wavelength of incident light and vary the angle of incidence when setting up our Structure. (It is just as simple to fix the incidence angle and calculate the transfer matrix as a function of the field wavelength.)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by making a Layer type of air and a Layer of glass. We'll do this for  a wavelength of 1 μm. Since there are only two layers and the transfer matrix method treats the first and last layers as semi-infinite, there is no need to provide a thickness for our glass and air layers. From the examples below, you can see that there are fields for","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"the material name\nthe layer thickness\na list of wavelengths\nthe real part of the refractive index (corresponding to the wavelength)\nthe imaginary part of the refractive index","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Details about different ways to make a layer are further on in the tutorial.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(url=\"https://github.com/garrekstemo/TransferMatrix.jl.git\")\nPkg.add(\"CairoMakie\")","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransferMatrix\n\nair = Layer(\"Air\", 0.0, [1.0e-6], [1.0], [0.0])\nglass = Layer(\"Glass\", 0.0, [1.0e-6], [1.5], [0.0])","category":"page"},{"location":"guide/tutorial/#Assembling-layers-into-a-structure","page":"Tutorial","title":"Assembling layers into a structure","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have our glass and air layers, we need to assemble them into a structure and provide the angles of the field with respect to the surface of the structure. We do this with the Structure type.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"θs = range(0., 85., length = 500)\ns = Structure([air, glass], [1.0e-6], collect(θs) .* π/180)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The first argument is just a list of layers. The second argument is a list of desired wavelengths. Often the refractive index data we have for  two materials are not given for exactly the same wavelengths.  TransferMatrix.jl uses an interpolation function to normalize the wavelengths and complex refractive indices for all layers from  this user-provided list of wavelengths. (Be careful if the range you provide goes beyond the range of the data that you have!) Now we can evaluate the angle-resolved spectrum using the function angle_resolved().","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"res = angle_resolved(s)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's also plot the result using the Makie.jl data visualization package.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\nbrewster = atan(1.5) * 180 / π\n\nf = Figure()\nax = Axis(f[1, 1], xlabel = \"Incidence Angle (°)\", ylabel = \"Reflectance / Transmittance\")\n\nlines!(θs, res.Tss[:, 1], color = :firebrick4, label = \"Ts\")\nlines!(θs, res.Tpp[:, 1], color = :orangered3, label = \"Tp\")\nlines!(θs, res.Rss[:, 1], color = :dodgerblue4, label = \"Rs\")\nlines!(θs, res.Rpp[:, 1], color = :dodgerblue1, label = \"Rp\")\nvlines!(brewster, color = :dodgerblue1, linestyle = :dash)\ntext!(\"Brewster angle\\n(Rp = 0)\", position = (35, 0.6))\n\naxislegend(ax)\nf","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can see that the result of the angle-resolved calculation has four solutions: the s-wave and p-wave for both the reflected and transmitted waves. And we see that the Brewster angle is arctanleft( n_textglass n_textair right) approx 56^circ, as expected. Simultaneous calculation of s- and p-polarized incident waves is a feature of the  general 4x4 transfer matrix method being used. The angle_resolved function will also loop through all wavelengths so that you can plot a color plot of wavelength and angle versus transmittance (or reflectance).","category":"page"},{"location":"guide/tutorial/#Defining-a-Layer","page":"Tutorial","title":"Defining a Layer","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Layer type is immutable. Once you make one, you can't change any of its  characteristics later. There are two ways to define a Layer. The first is by  directly filling in the argument fields:","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Layer(material, thickness, λs, ns, κs)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"You may choose any units you like for thickness and wavelength,  but they must be the same (e.g. both are in nanometers). The material is just a String. Wavelength, and the  refractive index arguments must be Arrays, even if they just contain  with a single item. A very manual way to make a Layer might look like this:","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"glass = Layer(\"Glass\", 20.0e-6, [1.0e-6, 1.1e-6, 1.3e-6], [0.0, 0.0, 0.0])","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"This way works well for simple Layers or when you just need a single frequency for an angle-resolved calculation, but this is a lot more work if the refractive index  is pulled from a database or a file. The website refractiveindex.info contains a large database of refractive indices from peer-reviewed papers. TransferMatrix.jl makes it easy to use a CSV file downloaded from this website with the read_refractive() function, which returns a Layer type. You can choose  to include (or not) the real/imaginary part of the complex refractive index. Note that  this refractiveindex.info stores wavelength information in units of micrometers.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"glass = read_refractive(\"/path/to/file.csv\", \"Glass\", 20e-6, div=1e6)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The div keyword argument at the end of read_refractive represents the  desired unit conversion. In this case, if we want everything to be in meters we must divide each wavelength in the raw data by 10^6. Alternatively, we can  change the thickness units to micrometers. Just be careful that all Layers in your multi-layered structure have consistent units.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Layer properties can be independently queried. To get the material name or thickness,  for example, you can just type:","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> glass.material\n\"Glass\"\njulia> glass.thickness\n2.0e-5","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The same can be done to get wavelengths (glass.λ) (get λ by typing \\lambda), real refractive index (glass.n), and complex refractive index (glass.κ) (get κ by typing \\kappa). (A very useful feature of Julia is built-in support for unicode characters).","category":"page"},{"location":"guide/tutorial/#A-simple-multi-layered-structure","page":"Tutorial","title":"A simple multi-layered structure","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we can make Layers, we can put them together to calculate  the transfer matrix for a multi-layered structure and plot the reflectance and transmittance spectra. A very important structure in optics is the Fabry-Pérot etalon, which can be made with two mirrors that face each other with a gap between them. Let's make this a  little more challenging (and experimentally realistic) by  mounting the mirrors onto windows that are transparent in our chosen wavelength range. The gap will simply be 20 μm of air. We will scan in the mid infrared between 4 and 6 μm and use data generated via the Lorentz-Drude model for each 10 nm-thick gold layer and experimental data from Malitson, 1963 for the windows. (Some example refractive index data are in the refractive_index_data folder in the simulation src directory. The ../ syntax denotes a relative file path one level up from the current folder.)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"λs = range(4.0, 6.0, length = 1000) .* 1e-6\naufile = \"../../../../refractive_index_data/Au_nk_0.248-6.20um_Lorentz-Drude_Rakic1998.csv\"\ncaf2file = \"../../../../refractive_index_data/CaF2_n_0.23-9.7um_Malitson.csv\"\n\nair = Layer(\"Air\", 20e-6, collect(λs), fill(1.0, length(λs)), zeros(length(λs)))\nau = read_refractive(aufile, \"Au\", 10e-9, div=1e6)\ncaf2 = read_refractive(caf2file, \"CaF2\", 5.0e-6, div=1e6)\n\ns = Structure([caf2, au, air, au, caf2], collect(λs), [0.0])\nTp, Ts, Rp, Rs = calculate_tr(s)\n\nf, ax, l = lines(λs .* 1e6, Ts)\nax.xlabel = \"Wavelength\"\nax.ylabel = \"Transmittance\"\nf","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"It is easy to combine manually-generated data and experimental data to calculate the global transfer matrix.","category":"page"},{"location":"guide/tutorial/#Periodic-structures-with-a-YAML-config-file","page":"Tutorial","title":"Periodic structures with a YAML config file","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"With the tools described above, it is pretty easy to make any kind of multi-layered structure that you want. A very large structure, maybe one with repeating layers, is also not difficult to build. However, it would be useful to be able to load a  structure from a set of parameters so that it can be saved or even shared with others for better reproducibility. To do this, a Structure can be loaded directly from a YAML file (using YAML.jl). ","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's demonstrate this with a quarter-wave stack, which is a periodic structure with two alternative layers where the thickness is one fourth of the wavelength within the medium, or the relation","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"d_i = fraclambda4n_i","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"where d_i is the thickness for layer i, lambda is the electric field wavelength in vacuum, and n_i is the index of refraction for layer i.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is the YAML file that gives us this:","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"# All units in micrometers\n\nmin_wavelength: 0.5\nmax_wavelength: 2.0\nn_wavelengths: 1000\n\n# Theta in radians\ntheta_i: 0.0\ntheta_f: 0.0\nn_theta: 1\n\nlayers:\n\n    layer1:\n        material: Air\n        thickness: 0.5\n        wavelength: 1.0\n        refractive_index: 1.0\n        extinction_coeff: 0.0\n\n    layer2:\n        periods: 3\n        layers:\n          layer1:\n            material: \"ZnS n=2.32\"\n            thickness: 0.1077\n            refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv\n          layer2:\n            material: \"MgF2 n=1.36\"\n            thickness: 0.1838\n            refractive_filename: MgF2_nk_0.03-2.0um_Rodriguez2017.csv\n\n    layer3: \n        material: \"ZnS n=2.32\"\n        thickness: 0.1838\n        refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"At the top, we set the minimum and maximum wavelengths to be calculated, with the  total number of points set to 1000. We won't do an angle-resolved calculation, so initial and final theta are zero (with n_theta just one). Next the multi-layered structure is defined under layers:. The first layer is just air, so we don't need a file for this and can set the refractive index for a single wavelength. These values and wavelength are expanded when the YAML file is loaded. The final layer (layer3) is zinc sulfide (ZnS), which is loaded from a CSV file downloaded from refractiveindex.info. The middle section (layer2) is where we define the periodic structure. The first item determines how many periods we want. In this case, periods: 3. Then we  set the layers that alternate under another layers section. You can see that the first layer layer1 is zinc sulfide and the second layer layer2 is magnesium fluoride (MgF₂). The number of times that these two layers are repeated can easily be changed by editing the periods field. You can even have multiple repeating structures within the global structure for arbitrarily complicated structures.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"To load the YAML config file into a Structure, we use the load_from_yaml() function. You can find this example in the default_config folder in the quarter-wave.yaml file.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"s = load_from_yaml(\"../../../default_config/quarter-wave.yaml\", 1e-6)\nTp, Ts, Rp, Rs = calculate_tr(s)","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"This particular example is taken from Pochi Yeh's Optical Waves in Layered Media on page 110. You can find the reflectivity of this structure in Table 5.1. The values we have calculated are slightly different since the data used here is slightly dispersive with wavelength, but the example in the book takes flat refractive index values. You can try plotting this structure for an increasing number of periods and observe how the reflectance near lambda = 1 μm increases.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\nf = Figure()\nax = Axis(f[1, 1], title = \"ZnS / MgF quarter-wave with 3 layers\", xlabel = \"Wavelength (nm)\", ylabel = \"Transmittance / Reflectance\")\n\nlines!(s.λ .* 1e9, Tp, label = \"T\")\nlines!(s.λ .* 1e9, Rp, label = \"R\")\naxislegend(ax, position = :rc)\n\nf","category":"page"},{"location":"guide/tutorial/#Electric-field","page":"Tutorial","title":"Electric field","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The electric field can be calculated as a function of position within the layered structure using the electric_field() function, which takes the Structure and desired wavelength λ, as well as optional argument angle of incidence θ and optional keyword argument for the number of data points numpoints. We can plot the field profile for the distributed bragg reflector (DBR) we constructed in the previous section. Let's do this for λ = 1 μm.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"λ_field = 1e-6\nfield = electric_field(s, λ_field)\n\nf = Figure()\nax = Axis(f[1, 1], title = \"Electric Field Profile at λ = $(Int(λ_field * 1e9)) nm\", xlabel = \"z position (nm)\", ylabel = \"Field intensity (a.u.)\")\n\nlines!(field.z .* 1e9, real(field.p[1, :]).^2)\n\nvlines!(field.boundaries[1], color = :gray30, linestyle = :dash)\nvlines!(field.boundaries[end] * 1e9, color = :gray30, linestyle = :dash)\n\nf","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The electric field result contains the position z within the structure, the (x, y, z) components (corresponding to the first, second, and third components of the Array) of the p-polarized and s-polarized light, and the positions of the layer interfaces. So for example, to get the x-component of the p-polarized field along all of z, we would call field.p[1, :], as we have done above.","category":"page"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"The layer boundaries is useful for plotting (as shown in the figure above) and checking that the in-plane components are continuous throughout the structure, as required by Maxwell's interface conditions.","category":"page"},{"location":"guide/tutorial/#Minor-implementation-details","page":"Tutorial","title":"Minor implementation details","text":"","category":"section"},{"location":"guide/tutorial/","page":"Tutorial","title":"Tutorial","text":"Behind the scenes of the electric field calculation, a new Structure is actually being created and initialized for the user-supplied wavelength. The transfer matrix is again calculated for the provided wavelength and light incidence angle. Some solution of this sort is necessary because the exact wavelength that you may wish to calculate for may not be part of the original Structure.","category":"page"}]
}
