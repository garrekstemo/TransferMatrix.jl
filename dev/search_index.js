var documenterSearchIndex = {"docs":
[{"location":"guide/validation/#Physics-Validation","page":"Physics Validation","title":"Physics Validation","text":"TransferMatrix.jl includes built-in physics validation to help catch numerical issues and verify that results are physically meaningful. This page explains what gets validated and how to interpret warnings.","category":"section"},{"location":"guide/validation/#Enabling-Validation","page":"Physics Validation","title":"Enabling Validation","text":"Enable validation by passing validate=true to transfer:\n\nresult = transfer(λ, layers; validate=true)\n\nValidation is disabled by default to avoid performance overhead in production calculations.","category":"section"},{"location":"guide/validation/#Physical-Constraints","page":"Physics Validation","title":"Physical Constraints","text":"The validation checks four physical constraints:","category":"section"},{"location":"guide/validation/#NaN-Detection","page":"Physics Validation","title":"NaN Detection","text":"Detects whether any of Tpp, Tss, Rpp, Rss are NaN. NaN values indicate a numerical failure somewhere in the calculation pipeline. This can occur when:\n\nLayer parameters create a singular or near-singular transfer matrix\nExtreme refractive index values or layer thicknesses cause numerical overflow\n\nExample warning:\n\n┌ Warning: NaN detected in R/T values\n│   Tpp = NaN\n│   Tss = 0.85\n│   Rpp = NaN\n│   Rss = 0.15\n└ @ TransferMatrix","category":"section"},{"location":"guide/validation/#Bounds-Check:-0-R,-T-1","page":"Physics Validation","title":"Bounds Check: 0 ≤ R, T ≤ 1","text":"Reflectance and transmittance must be between 0 and 1. These are ratios of energy flux. Negative values indicate a sign error in the Poynting vector calculation. Values greater than 1 indicate numerical instability or an error in the transfer matrix construction.\n\nCommon causes of violations:\n\nSign convention errors in the formalism\nIncorrect mode sorting (transmitted vs. reflected modes swapped)\nNumerical overflow in the propagation matrix for very thick layers\n\nExample warning:\n\n┌ Warning: Transmittance Tpp out of bounds [0, 1]\n│   Tpp = -0.02\n└ @ TransferMatrix","category":"section"},{"location":"guide/validation/#Energy-Conservation:-R-T-1-(Lossless-Media)","page":"Physics Validation","title":"Energy Conservation: R + T = 1 (Lossless Media)","text":"For non-absorbing media, the sum of reflectance and transmittance must equal 1. This is a fundamental consequence of energy conservation. In a lossless system, all incident power must either be reflected or transmitted—none is absorbed. The physics: The Poynting vector mathbfS = frac12textRe(mathbfE times mathbfH^*) represents the time-averaged power flow. The z-component gives the power flux through a surface. For energy conservation:\n\nS_textincident = S_textreflected + S_texttransmitted\n\nDividing by S_textincident:\n\n1 = R + T\n\nImportant note: The amplitude transmission coefficient t^2 is not equal to the transmittance T in general. The true transmittance must account for the change in wave impedance between media:\n\nT = fracn_2 costheta_2n_1 costheta_1 t^2\n\nThis is why TransferMatrix.jl uses Poynting vector calculations rather than simply squaring the transmission coefficient.\n\nExample warning:\n\n┌ Warning: Energy conservation violated for p-polarization\n│   Tpp = 0.72\n│   Rpp = 0.25\n│   sum = 0.97\n│   expected = 1.0\n│   deviation = 0.03\n└ @ TransferMatrix","category":"section"},{"location":"guide/validation/#Absorption-Bound:-R-T-1-(Lossy-Media)","page":"Physics Validation","title":"Absorption Bound: R + T ≤ 1 (Lossy Media)","text":"For absorbing media (where any layer has a non-zero extinction coefficient), the sum R + T must not exceed 1. In absorbing media, some energy is converted to heat. The absorbed fraction is:\n\nA = 1 - R - T\n\nIf R + T > 1, it would imply negative absorption (energy creation), which is unphysical.\n\nNote: The validation does not check that R + T < 1 for lossy media—only that it doesn't exceed 1. A value of exactly 1.0 could occur if the absorbing layer is very thin or if the imaginary part of the refractive index is negligible.\n\nExample warning:\n\n┌ Warning: Absorption violation: R + T > 1 for p-polarization\n│   Tpp = 0.65\n│   Rpp = 0.42\n│   sum = 1.07\n└ @ TransferMatrix","category":"section"},{"location":"guide/validation/#When-to-Use-Validation","page":"Physics Validation","title":"When to Use Validation","text":"Use validate=true when:\n\nDeveloping new simulations or testing new layer configurations\nDebugging unexpected results\nWorking with edge cases (grazing incidence, very thin layers, high refractive index contrast)\nValidating against experimental data or other simulation tools\n\nSkip validation (validate=false, the default) when:\n\nRunning production calculations where you've already verified the setup\nPerformance is critical (e.g., large parameter sweeps)\nYou're certain the layer stack is well-behaved","category":"section"},{"location":"guide/validation/#Interpreting-Validation-Failures","page":"Physics Validation","title":"Interpreting Validation Failures","text":"If you see validation warnings, here are some debugging steps:\n\nCheck layer definitions: Ensure thicknesses are positive and refractive indices are physically reasonable.\nCheck units: All lengths (wavelength, thickness) must use the same units. Micrometers (μm) are recommended.\nCheck for edge cases:\nGrazing incidence (θ → 90°) can cause numerical issues\nVery thin layers (thickness ≪ wavelength) may require higher precision\nVery thick layers (thickness ≫ wavelength) can cause overflow in the propagation matrix\nSimplify the problem: Test with a single interface (two layers) to verify basic functionality.\nCompare methods: The code calculates R from transfer matrix coefficients and T from Poynting vectors. Significant disagreement suggests an issue with one of the calculation paths.","category":"section"},{"location":"guide/validation/#Limitations","page":"Physics Validation","title":"Limitations","text":"Validation does not catch all possible errors:\n\nField continuity: Tangential E and H fields should be continuous across interfaces. This is tested in the test suite but not validated at runtime.\nIncorrect but consistent results: If there's a systematic error that affects both R and T equally, energy conservation might still hold.\nMaterial data errors: Validation can't detect if your refractive index data is wrong—only that the calculation is self-consistent.\nAnisotropic media issues: The validation assumes isotropic materials. For birefringent media, additional checks may be needed.","category":"section"},{"location":"guide/validation/#Tolerance-Parameters","page":"Physics Validation","title":"Tolerance Parameters","text":"The internal _validate_physics function uses these default tolerances:\n\nParameter Default Purpose\natol 1e-6 Absolute tolerance for R + T ≈ 1\nk_threshold 1e-10 Threshold for considering a layer lossless","category":"section"},{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"These functions are not exported by the TransferMatrix.jl module and can be called using the TransferMatrix. qualifier. Use these methods if you wish to construct a transfer matrix method manually step by step or modify intermediate steps.","category":"section"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"Pages = [\"internals.md\"]","category":"section"},{"location":"lib/internals/#General-Transfer-Matrix-Method","page":"Internals","title":"General Transfer Matrix Method","text":"","category":"section"},{"location":"lib/internals/#TransferMatrix._sweep_spectra-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix._sweep_spectra","text":"sweep_angle(λs, θs, layers; threads=true, verbose=false)\n\nCalculate transmittance/reflectance spectra over wavelength and angle of incidence.\n\nReturns a TransferResult with fields Tpp, Tss, Rpp, Rss, each a matrix of size (length(θs), length(λs)).\n\nArguments\n\nλs: Vector of wavelengths in μm\nθs: Vector of angles of incidence in radians\nlayers: AbstractVector{<:Layer} representing the stack\nthreads: Enable multithreading (default: true)\nverbose: Print thread count info (default: false)\n\nUnits\n\nWavelengths: μm (micrometers) recommended\nAngles: radians\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix._validate_physics-NTuple{6, Any}","page":"Internals","title":"TransferMatrix._validate_physics","text":"_validate_physics(λ, layers, Tpp, Tss, Rpp, Rss; atol=1e-6, k_threshold=1e-10)\n\nValidate physical constraints on R and T values:\n\nBounds check: 0 ≤ R, T ≤ 1 (always)\nEnergy conservation: R + T ≈ 1 (for non-absorbing media only)\n\nIssues warnings if constraints are violated.\n\nInternal function called by transfer when validate=true.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.abs_ratio-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.abs_ratio","text":"Ratio of the absolution squares of two components used to evaluate if a material is birefringent.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.evaluate_birefringence-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.evaluate_birefringence","text":"evaluate_birefringence(Ψ, S, t_modes, r_modes)\n\nFor the four modes (two transmitting and two reflecting), the ratio\n\nbeginaligned\n    C = E_x^2  (E_x^2 + E_y^2) = Ψ_1^2  (Ψ_1^2 + Ψ_3^2)\nendaligned\n\nis evaluated. Recall that the values for the electric field are contained in the eigenvector matrix, Ψ.\n\nIf the layer material is birefringent, there will be anisotropy in the dielectric tensor. If this is the case, the x and y components of the  Poynting vector needs to be analyzed (eqn 15 in Passler et al., 2017):\n\nC = S_x^2  (S_x^2 + S_y^2)\n\nIf there is no birefringence, then the electric field is analyzed. This analysis follows\n\nLi et al., 1988, https://doi.org/10.1364/AO.27.001334\n\nand the use of the Poynting vector is from\n\nPassler et al., 2017, https://doi.org/10.1364/JOSAB.34.002128 Passler et al., 2019, https://doi.org/10.1364/JOSAB.36.003246\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.poynting-NTuple{7, Any}","page":"Internals","title":"TransferMatrix.poynting","text":"poynting(ξ, q_in, q_out, γ_in, γ_out, t_coefs, r_coefs)\n\nCalculate the Poynting vector from wavevectors q, componments of the electric field γ, and transmission and reflection coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.poynting-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.poynting","text":"poynting(Ψ, a)\n\nCalculates the Poynting vector for the structure from Ψ and matrix a.\n\nFrom Berreman, 1972, Ψ is the column matrix:\n\nPsi = \n    beginpmatrix\n        Ex Hy Ey -Hx\n    endpmatrix\n\nfor a right-handed Cartesian coordinate system with the z-axis along the normal to the multilayer structure.\n\nBerreman, 1972, https://doi.org/10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.propagate-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.propagate","text":"propagate(λ, layers; θ=0.0, μ=1.0)\n\nCalculate the transfer matrix for the entire structure, as well as the Poynting vector for the structure.\n\nArguments\n\nλ: Wavelength\nlayers: Vector of Layer objects representing the stack\nθ: Angle of incidence in radians (default: 0.0, normal incidence)\nμ: Relative magnetic permeability (default: 1.0, non-magnetic)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.calculate_q-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.calculate_q","text":"calculate_q(Δ, a)\n\nThe four eigenvalues of q may be obtained from the  4x4 matrix Δ and then eigenvectors may be found for each eigenvalue. Here the eigenvalues must be sorted appropriately to avoid  potentially discontinuous solutions. This extends from the work in\n\nLi et al, 1988, https://doi.org/10.1364/AO.27.001334\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.calculate_γ-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.calculate_γ","text":"calculate_γ(ξ, q, ε, μ)\n\nThe 4 x 3 matrix γ contains vector components that belong  to the electric field calculated such that singularities are identified and removed.\n\nq[1] and q[2] are forward-traveling modes and q[3] and q[4] are backward-traveling modes.\n\nThis is based on the work in Xu, et al., 2000, https://doi.org/10.1103/PhysRevB.61.1740\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.construct_M","page":"Internals","title":"TransferMatrix.construct_M","text":"construct_M(ε, μ, ρ1, ρ2)\n\nConstruct the 6x6 matrix M from the dielectric and permeability tensors.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#TransferMatrix.construct_a-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.construct_a","text":"construct_a(ξ, M)\n\nConstruct the elements of the intermediate 6x6 matrix a in terms of the elements of matrix M (the 6x6 matrix holding the material dielectric and permeability tensors) and propagation vector ξ. This is implemented as described in \n\nBerreman, 1972, https://doi.org/10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.construct_Δ-Tuple{Any, Any, Any}","page":"Internals","title":"TransferMatrix.construct_Δ","text":"construct_Δ(ξ, M, a)\n\nConstruct the reordered matrix Δ in terms of the elements of the two matrices, M and a, and the in-plane reduced wavevector ξ = k_x  k_0. The matrix Δ is involved in the relation\n\n    fracdeltadelta zPsi = fraci omegacDelta Psi\n\nand Δ is the reordered S matrix in Berreman's formulation.\n\nBerreman, 1972, https://doi.org/10.1364/JOSA.62.000502\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.dynamical_matrix-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.dynamical_matrix","text":"dynamical_matrix(ξ, q, γ, μ)\n\nThe dynamical matrix relating two layers at the interface where matrix A_i for layer i relates the field E_i to the field in the previous layer i - 1 via\n\n    A_i-1E_i-1 = A_iE_i\n\nXu, et al., 2000, https://doi.org/10.1103/PhysRevB.61.1740\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.layer_matrices-NTuple{4, Any}","page":"Internals","title":"TransferMatrix.layer_matrices","text":"layer_matrices(ω, ξ, layer, μ)\n\nCalculate all parameters for a single layer, particularly the propagation matrix and dynamical matrix so that the overall transfer matrix can be calculated.\n\nSupports both isotropic layers (single refractive index) and anisotropic layers (different refractive indices along principal axes), with optional crystal rotation via Euler angles.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.permeability_tensor-Tuple{Any, Any, Any}","page":"Internals","title":"TransferMatrix.permeability_tensor","text":"permeability_tensor(μ1, μ2, μ3)\n\nThis produces the diagonal permeability tensor,  which is identical to the way we build the dielectric_tensor, and we include this function simply for completeness.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#TransferMatrix.propagation_matrix-Tuple{Any, Any}","page":"Internals","title":"TransferMatrix.propagation_matrix","text":"propagation_matrix(ω, q)\n\nReturns a callable object that propagates the electromagnetic field a distance z through a material for a frequency ω and wavevector q.\n\nThe propagation matrix is diagonal with elements:\n\nP(z) = diag(exp(-iωq₁z/c), exp(-iωq₂z/c), exp(-iωq₃z/c), exp(-iωq₄z/c))\n\nThis uses the exp(-iωt) time convention, consistent with Berreman (1972) and Passler & Paarmann (2017). Note that Yeh uses exp(+iωt), which would flip the sign in the exponent.\n\n\n\n\n\n","category":"method"},{"location":"guide/quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"If you just want to get started with a transfer matrix calculation and plot the transmittance or reflectance  spectrum, this is the place to start. First install TransferMatrix.jl by typing ] from the Julia REPL to enter package mode, then enter\n\npkg> add TransferMatrix","category":"section"},{"location":"guide/quickstart/#Quarter-wave-mirror","page":"Quick Start","title":"Quarter-wave mirror","text":"Let's make a simple quarter-wave mirror, or distributed bragg reflector (DBR). We will do this via alternating layers of titanium dioxide (n = 2.13) and silica (n = 1.46) optimized for a wavelength of 630 nm. We'll make three periods of these two layers and and layer of air. This 4x4 transfer matrix method simultaneously calculates the transmittance and reflectance for s-polarized and p-polarized  radiation. (We are using the powerful plotting library Makie.jl to produce the figures.)\n\nusing TransferMatrix\nusing CairoMakie\nusing RefractiveIndex\n\nn_air = RefractiveMaterial(\"other\", \"air\", \"Ciddor\")\nn_tio2 = RefractiveMaterial(\"main\", \"TiO2\", \"Sarkar\")\nn_sio2 = RefractiveMaterial(\"main\", \"SiO2\", \"Rodriguez-de_Marcos\")\n\nλ_0 = 0.63  # μm\nt_tio2 = λ_0 / (4 * n_tio2(λ_0))\nt_sio2 = λ_0 / (4 * n_sio2(λ_0))\n\nair = Layer(n_air, 0.1)\ntio2 = Layer(n_tio2, t_tio2)\nsio2 = Layer(n_sio2, t_sio2)\n\nunit = [tio2, sio2]\nperiods = 3\nlayers = [air, repeat(unit, periods)...]\n\nλs = 0.4:0.002:1.0\nRpp = Float64[]\nfor λ in λs\n    result = transfer(λ, layers)\n    push!(Rpp, result.Rpp)\nend\n\n\nf, ax, l = lines(λs .* 1e3, Rpp)\nax.xlabel = \"Wavelength (nm)\"\nax.ylabel = \"Reflectance\"\n\nf\n\nNote: Layer is parametric as Layer{F,T}. When annotating collections, prefer AbstractVector{<:Layer} rather than Vector{Layer}.\n\nNow let's try a few more periods and plot them all together to see how the reflectance changes with increasing number of layers. Notice that we are adding new layers directly to the structure and not creating a new structure.\n\nnperiods = 6\n\nfor i in 1:nperiods\n    push!(layers, tio2)\n    push!(layers, sio2)\n    Rpp = Float64[]\n    if i%3 == 0\n        for λ in λs\n            result = transfer(λ, layers)\n            push!(Rpp, result.Rpp)\n        end\n        lines!(ax, λs .* 1e3, Rpp, label = \"$(i + 3) periods\")\n    end\nend\n\naxislegend(ax)\nf","category":"section"},{"location":"guide/quickstart/#Physics-Validation","page":"Quick Start","title":"Physics Validation","text":"When developing or debugging, enable physics validation to catch numerical issues early:\n\nresult = transfer(λ, layers; validate=true)\n\nWith validate=true, the function checks:\n\nBounds: 0 ≤ R, T ≤ 1 (catches NaN, negative values, numerical instability)\nEnergy conservation: R + T ≈ 1 for non-absorbing media\nAbsorption bound: R + T ≤ 1 for absorbing media\n\nWarnings are issued for any violations, helping you identify problems with layer definitions or edge cases in your simulation.","category":"section"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"These functions and types are to be used for transfer matrix calculation based on the sources used. If you wish to modify any of the steps in the  calculation, refer to the private API.","category":"section"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"lib/public/#Transfer-Matrix-Functions","page":"Public","title":"Transfer Matrix Functions","text":"","category":"section"},{"location":"lib/public/#Miscellaneous-Optics-Functions","page":"Public","title":"Miscellaneous Optics Functions","text":"","category":"section"},{"location":"lib/public/#TransferMatrix.TransferResult","page":"Public","title":"TransferMatrix.TransferResult","text":"TransferResult{T}\n\nContainer for reflectance and transmittance results from transfer matrix calculations.\n\nFields\n\nTpp::T: p-polarized transmittance (p-in → p-out)\nTss::T: s-polarized transmittance (s-in → s-out)\nTps::T: cross-polarized transmittance (p-in → s-out)\nTsp::T: cross-polarized transmittance (s-in → p-out)\nRpp::T: p-polarized reflectance (p-in → p-out)\nRss::T: s-polarized reflectance (s-in → s-out)\nRps::T: cross-polarized reflectance (p-in → s-out)\nRsp::T: cross-polarized reflectance (s-in → p-out)\n\nFor single-wavelength calculations via transfer(), T is Float64. For sweep calculations via sweep_angle() or sweep_thickness(), T is Matrix{Float64}.\n\nnote: Cross-polarization terms\nThe cross-polarization terms (Tps, Tsp, Rps, Rsp) are zero for isotropic media and become non-zero for anisotropic (birefringent) materials.\n\nExamples\n\n# Single wavelength - returns TransferResult{Float64}\nresult = transfer(1.0, layers)\nresult.Tpp  # Float64\n\n# Sweep - returns TransferResult{Matrix{Float64}}\nresult = sweep_angle(λs, θs, layers)\nresult.Tpp  # Matrix{Float64}\n\n# Destructuring works\n(; Tpp, Rpp) = transfer(1.0, layers)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TransferMatrix.calculate_tr-Tuple{Any}","page":"Public","title":"TransferMatrix.calculate_tr","text":"calculate_tr(Γ)\n\nCalculate reflectance and transmittance for the total stack. This takes the matrix Γ* in Passler, et al., but for brevity we call it Γ in this function.\n\nThe original formalism is from: Yeh, 1979, https://doi.org/10.1364/JOSA.69.000742\n\nbut the ordering of reflection/transmission coefficients  is modified in Passler, et al. 2017 https://doi.org/10.1364/JOSAB.34.002128\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.calculate_tr-Tuple{TransferMatrix.Poynting}","page":"Public","title":"TransferMatrix.calculate_tr","text":"calculate_tr(S::Poynting)\n\nCalculate transmittance and reflectance from the Poynting vector struct, which contains incident, transmitted, and reflected energy flux for both p-polarized and s-polarized waves.\n\nReturns (Tpp, Tss, Rpp, Rss).\n\nSign Convention\n\nThe reflected Poynting vector z-component is negative (pointing in -z direction), so the negative sign in Rpp = -S.refl_p[3] / S.in_p[3] yields positive reflectance.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.efield-Tuple{Any, Any}","page":"Public","title":"TransferMatrix.efield","text":"efield(λ, layers; θ=0.0, μ=1.0, dz=0.001)\n\nCalculate the electric field profile throughout the layered structure.\n\nReturns an ElectricField struct containing:\n\nz: Position coordinates along the structure\np: Electric field components (Ex, Ey, Ez) for p-polarized incidence\ns: Electric field components (Ex, Ey, Ez) for s-polarized incidence\nboundaries: z-positions of layer interfaces\n\nArguments\n\nλ: Wavelength in μm (must match units used for layer thicknesses)\nlayers: Vector of Layer objects representing the stack\nθ: Angle of incidence in radians (default: 0.0, normal incidence)\nμ: Relative magnetic permeability (default: 1.0, non-magnetic)\ndz: Spatial step size in μm for field sampling (default: 0.001)\n\nWave Propagation Convention\n\nLight propagates in the +z direction (from first layer toward last layer)\nz = 0 is at the first interface (between layer 1 and layer 2)\nNegative z values are inside the first (incident) layer\nθ is measured from the surface normal (z-axis)\n\nUnits\n\nAll lengths (λ, thickness, dz, z): μm (micrometers) recommended\nAngle: radians\nElectric field: arbitrary units (normalized to incident field)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.sweep_thickness-Tuple{Any, Any, Any, Int64}","page":"Public","title":"TransferMatrix.sweep_thickness","text":"sweep_thickness(λs, ts, layers, t_index; θ=0.0, threads=true, verbose=false)\n\nSweep the thickness of a specific layer and calculate transmittance/reflectance spectra.\n\nReturns a TransferResult with fields Tpp, Tss, Rpp, Rss, each a matrix of size (length(ts), length(λs)).\n\nArguments\n\nλs: Vector of wavelengths in μm\nts: Vector of thicknesses in μm to sweep\nlayers: AbstractVector{<:Layer} representing the stack\nt_index: Index of the layer (1-based) whose thickness to vary\nθ: Angle of incidence in radians (default: 0.0, normal incidence)\nthreads: Enable multithreading (default: true)\nverbose: Print thread count info (default: false)\n\nUnits\n\nWavelengths and thicknesses: μm (micrometers) recommended\nAngle: radians\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.transfer-Tuple{Any, Any}","page":"Public","title":"TransferMatrix.transfer","text":"transfer(λ, layers; θ=0.0, μ=1.0, validate=false)\n\nCalculate the transmittance and reflectance of a layered structure.\n\nReturns (Tpp, Tss, Rpp, Rss) where:\n\nTpp, Tss: p- and s-polarized transmittance\nRpp, Rss: p- and s-polarized reflectance\n\nTransmittance is calculated via Poynting vectors for accurate energy flow. Reflectance is calculated directly from transfer matrix elements.\n\nArguments\n\nλ: Wavelength in μm (must match units used for layer thicknesses)\nlayers: Vector of Layer objects representing the stack\nθ: Angle of incidence in radians (default: 0.0, normal incidence)\nμ: Relative magnetic permeability (default: 1.0, non-magnetic)\nvalidate: Check energy conservation R + T ≈ 1 for non-absorbing media (default: false)\n\nWave Propagation Convention\n\nLight propagates in the +z direction (from first layer toward last layer)\nThe first and last layers are treated as semi-infinite media\nθ is measured from the surface normal (z-axis)\n\nUnits\n\nWavelength and thicknesses: μm (micrometers) recommended\nAngle: radians\nTransmittance/Reflectance: dimensionless (0 to 1)\n\nPhysics Validation\n\nWhen validate=true, the function checks:\n\nBounds: 0 ≤ R, T ≤ 1 (catches NaN, negative values, numerical instability)\nEnergy conservation: R + T ≈ 1 for non-absorbing media (imag(n) < 1e-10)\nAbsorption bound: R + T ≤ 1 for absorbing media\n\nWarnings are issued for any violations.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.Layer","page":"Public","title":"TransferMatrix.Layer","text":"Layer(material, thickness)\nLayer(nx, ny, nz, thickness)\n\nConstruct a single layer for transfer matrix calculations.\n\nIsotropic Layer (single refractive index)\n\nLayer(material, thickness)\n\nmaterial: Refractive material (from RefractiveIndex.jl) or a dispersion function λ -> n(λ)\nthickness: Layer thickness in the same units as wavelength (typically μm)\n\nAnisotropic Layer (biaxial: three refractive indices)\n\nLayer(nx, ny, nz, thickness)\n\nnx, ny, nz: Dispersion functions λ -> n(λ) for each principal axis\nthickness: Layer thickness in μm\n\nFor uniaxial materials, set two axes equal (e.g., nx = ny for optic axis along z).\n\nUnits Convention\n\nAll length quantities (wavelength λ, thickness, dz) must use consistent units. Following RefractiveIndex.jl conventions, micrometers (μm) are recommended.\n\nLayer is parametric as Layer{F,T} where F is the dispersion function type and T is the thickness type. For anisotropic layers, F is a Tuple of three dispersion functions.\n\nExamples\n\n# Isotropic: Using RefractiveIndex.jl material\nn_sio2 = RefractiveMaterial(\"main\", \"SiO2\", \"Malitson\")\nlayer = Layer(n_sio2, 0.1)  # 100 nm = 0.1 μm\n\n# Isotropic: Using custom dispersion function\nlayer = Layer(λ -> 1.5 + 0.01im, 0.25)  # constant n = 1.5 + 0.01i\n\n# Anisotropic: Uniaxial crystal (calcite-like, optic axis along z)\nno = λ -> 1.658  # ordinary index\nne = λ -> 1.486  # extraordinary index\nlayer = Layer(no, no, ne, 0.5)\n\n# Anisotropic: Biaxial crystal\nlayer = Layer(λ -> 1.5, λ -> 1.6, λ -> 1.7, 0.3)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TransferMatrix.Layer-Union{Tuple{T}, Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{F1, F2, F3, T}} where {F1, F2, F3, T<:Real}","page":"Public","title":"TransferMatrix.Layer","text":"Layer(nx, ny, nz, thickness; euler=(0,0,0))\n\nConstruct an anisotropic layer with different refractive indices along each principal axis.\n\nArguments\n\nnx, ny, nz: Dispersion functions λ -> n(λ) for each principal axis\nthickness: Layer thickness in μm\neuler: Optional tuple (φ, θ, ψ) of ZYZ Euler angles in radians (default: no rotation)\n\nThe dielectric tensor is constructed as a diagonal matrix with εi = ni² in the crystal frame, then rotated to the lab frame using the Euler angles.\n\nEuler Angle Convention (ZYZ)\n\nφ (phi): First rotation about z-axis\nθ (theta): Rotation about new y-axis (tilt angle from z)\nψ (psi): Second rotation about new z-axis\n\nExamples\n\n# Uniaxial crystal with optic axis along z (no rotation needed)\nlayer = Layer(no, no, ne, 0.5)\n\n# Same crystal with optic axis tilted 45° from z in the xz-plane\nlayer = Layer(no, no, ne, 0.5; euler=(0, π/4, 0))\n\n# Optic axis in the xy-plane at 30° from x\nlayer = Layer(no, no, ne, 0.5; euler=(π/6, π/2, 0))\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_constant-Tuple{Real, Real}","page":"Public","title":"TransferMatrix.dielectric_constant","text":"dielectric_constant(n_re::Real, n_im::Real)\n\nReturn the complex dielectric function from the real and imaginary parts of the index of refraction.\n\nThe complex index of refraction, given by\n\n    n' = n_re + i * n_im\n\n(in terms of nre and nim), can be used to obtain the frequency-dependent complex dielectric function\n\n    ε_r(ω) = ε' + iε''\n\nvia the relation\n\n    (n_re + i * n_im)^2 = ε' + iε''.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.find_bounds-Tuple{Any}","page":"Public","title":"TransferMatrix.find_bounds","text":"find_bounds(layers)\n\nFind the unitful z coordinate for all layer-layer interfaces in the structure, with the first interface starting at z = 0. (negative z corresponds to positions inside the first layer.)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.get_euler_angles-Tuple{Layer}","page":"Public","title":"TransferMatrix.get_euler_angles","text":"get_euler_angles(layer::Layer)\n\nReturn the Euler angles (φ, θ, ψ) for crystal rotation.\n\nFor isotropic layers or unrotated anisotropic layers, returns (0.0, 0.0, 0.0). For rotated anisotropic layers, returns the stored angles.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.get_refractive_indices-Tuple{Layer, Any}","page":"Public","title":"TransferMatrix.get_refractive_indices","text":"get_refractive_indices(layer::Layer, λ)\n\nReturn the refractive indices for a layer at wavelength λ.\n\nFor isotropic layers, returns (n, n, n) where n is the scalar refractive index. For anisotropic layers, returns (nx, ny, nz) for each principal axis.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.isanisotropic-Tuple{Layer}","page":"Public","title":"TransferMatrix.isanisotropic","text":"isanisotropic(layer::Layer)\n\nReturn true if the layer has anisotropic optical properties (different refractive indices along principal axes), false for isotropic layers.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.isrotated-Tuple{Layer}","page":"Public","title":"TransferMatrix.isrotated","text":"isrotated(layer::Layer)\n\nReturn true if the layer has non-zero Euler angles for crystal rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.refractive_index-Tuple{RefractiveIndex.RefractiveMaterial}","page":"Public","title":"TransferMatrix.refractive_index","text":"refractive_index(material::RefractiveMaterial)\n\nReturn a function that takes a wavelength and gives the complex refractive index.\n\nThe extinction coefficient availability is checked once at construction time to avoid try-catch overhead in the inner loop of spectral calculations.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dielectric_tensor-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.dielectric_tensor","text":"dielectric_tensor(ε1, ε2, ε3)\n\nReturn the diagonal complex dielectric tensor\n\nvarepsilon = \nbeginpmatrix\n    varepsilon_1  0  0 0  varepsilon_2   0 0  0  varepsilon_3\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.euler_rotation_matrix-Tuple{Real, Real, Real}","page":"Public","title":"TransferMatrix.euler_rotation_matrix","text":"euler_rotation_matrix(φ, θ, ψ)\n\nReturn the 3×3 rotation matrix for ZYZ Euler angles (in radians).\n\nThis transforms vectors from the crystal frame to the lab frame: v_lab = R * v_crystal\n\nThe rotation is performed as: R = Rz(φ) * Ry(θ) * Rz(ψ)\n\nConvention\n\nφ (phi): First rotation about z-axis (0 to 2π)\nθ (theta): Rotation about new y-axis (0 to π) - the tilt angle\nψ (psi): Second rotation about new z-axis (0 to 2π)\n\nCommon cases\n\nOptic axis along z: (0, 0, 0) - no rotation needed\nOptic axis in xz-plane at angle θ from z: (0, θ, 0)\nQuarter-wave plate at 45°: (π/4, π/2, 0) for optic axis in xy-plane\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.rotate_dielectric_tensor-Tuple{LinearAlgebra.Diagonal, StaticArraysCore.SMatrix{3, 3}}","page":"Public","title":"TransferMatrix.rotate_dielectric_tensor","text":"rotate_dielectric_tensor(ε_diag, R)\n\nRotate a diagonal dielectric tensor from crystal frame to lab frame.\n\nGiven a diagonal tensor ε in the crystal's principal axis frame and a rotation matrix R, returns the rotated tensor: ε_lab = R * ε * R'\n\nArguments\n\nε_diag: Diagonal dielectric tensor in crystal frame\nR: 3×3 rotation matrix from euler_rotation_matrix\n\nReturns\n\nFull 3×3 SMatrix (may have off-diagonal elements after rotation)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.airy-NTuple{5, Any}","page":"Public","title":"TransferMatrix.airy","text":"airy(n0, nf, ns, d, λ; θ=0.0)\n\nCalculate the reflectance and transmittance of a single thin film using the exact Airy formula (multiple-beam interference).\n\nArguments\n\nn0: refractive index of incident medium (can be complex)\nnf: refractive index of the film (can be complex)\nns: refractive index of the substrate (can be complex)\nd: film thickness (same units as λ)\nλ: wavelength (same units as d)\nθ=0.0: angle of incidence in radians\n\nReturns\n\n(Rs, Rp, Ts, Tp) - reflectance and transmittance for s and p polarizations.\n\nPhysics\n\nThe Airy formula accounts for all multiple reflections within the film:\n\nr = fracr_01 + r_12 e^2idelta1 + r_01 r_12 e^2idelta\n\nwhere δ = 2π nf d cos(θf) / λ is the phase thickness and r₀₁, r₁₂ are the Fresnel reflection coefficients at the two interfaces.\n\nThis provides an exact analytical solution for validating numerical TMM results.\n\nExample\n\n# Quarter-wave anti-reflection coating\nn_air, n_film, n_glass = 1.0, 1.38, 1.52\nλ = 0.55  # μm\nd = λ / (4 * n_film)  # quarter-wave thickness\nRs, Rp, Ts, Tp = airy(n_air, n_film, n_glass, d, λ)\n\nSee also: fresnel, fresnel_coefficients\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.dbr_reflectivity-NTuple{5, Any}","page":"Public","title":"TransferMatrix.dbr_reflectivity","text":"dbr_reflectivity(no, ns, n1, n2, N)\n\nApproximate the reflectivity of a DBR structure with originating medium with refractive index no, substrate with index ns, and alternating materials with indices n1 and n2 and number of repetitions N. The repeated pair of materials are assumed to have quarter-wave thickness nd = lambda  4, where n is the refractive index, d is the layer thickness, and lambda is the wavelength of the light.\n\nDistributed Bragg reflector\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.fresnel-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.fresnel","text":"fresnel(θ, n1, n2)\n\nCalculate the reflectance for s-polarized and p-polarized light given the incidence angle θ (in radians) and indices of refraction of two media n1 and n2 at a plane interface.\n\nReturns (Rs, Rp) where Rs is s-polarized reflectance and Rp is p-polarized reflectance.\n\nThe Fresnel equations for reflectance are:\n\nR_s = left fracn_1 costheta_i - n_2 costheta_tn_1 costheta_i + n_2 costheta_t right^2\n\nR_p = left fracn_2 costheta_i - n_1 costheta_tn_2 costheta_i + n_1 costheta_t right^2\n\nwhere theta_t is the transmitted angle given by Snell's law: n_1 sintheta_i = n_2 sintheta_t.\n\nSpecial cases:\n\nAt grazing incidence (θ → π/2), returns (1.0, 1.0)\nFor total internal reflection (when n1 > n2 and θ > θ_critical), returns (1.0, 1.0)\n\nSee also: fresnel_coefficients for complex amplitude coefficients.\n\nFresnel equations\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.fresnel_coefficients-Tuple{Any, Any, Any}","page":"Public","title":"TransferMatrix.fresnel_coefficients","text":"fresnel_coefficients(θ, n1, n2)\n\nCalculate the Fresnel reflection and transmission amplitude coefficients for s-polarized and p-polarized light at a plane interface.\n\nReturns (rs, rp, ts, tp) where:\n\nrs, rp: reflection amplitude coefficients (complex)\nts, tp: transmission amplitude coefficients (complex)\n\nThese are the amplitude (not intensity) coefficients, so reflectance R = |r|² and transmittance requires the full expression T = (n2 cosθt)/(n1 cosθi) |t|².\n\nFor total internal reflection, the reflection coefficients have unit magnitude with a phase shift (evanescent wave), and transmission coefficients are zero.\n\nSee also: fresnel for intensity reflectances.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TransferMatrix.stopband-Tuple{Any, Any}","page":"Public","title":"TransferMatrix.stopband","text":"stopband(n1, n2)\n\nCalculate the frequency bandwidth Δf of the photonic stopband for a distributed bragg reflector (DBR) with two alternating materials of refractive indices n1 and n2.\n\n    fracDelta f_0f_0 = frac4pi arcsin left( fracn_2 - n_1n_2 + n_1 right)\n\nDistributed Bragg reflector\n\n\n\n\n\n","category":"method"},{"location":"bibliography/#References","page":"References","title":"References","text":"All references used for writing TransferMatrix.jl.\n\n[1] N. C. Passler, M. Jeannin, and A. Paarmann, Layer-Resolved Absorption of Light in Arbitrarily Anisotropic Heterostructures, Phys. Rev. B 101, 165425 (2020). \n[2] B. Garibello, N. Avilán, J. A. Galvis, and C. A. Herreño-Fierro, On the Singularity of the Yeh 4 × 4 Transfer Matrix Formalism, Journal of Modern Optics 67, 832 (2020). \n[3] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures: Erratum, J. Opt. Soc. Am. B 36, 3246 (2019). \n[4] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures, J. Opt. Soc. Am. B 34, 2128 (2017). \n[5] P. Yeh, Optical Waves in Layered Media (Wiley, 2005). \n[6] W. Xu, L. T. Wood, and T. D. Golding, Optical Degeneracies in Anisotropic Layered Media: Treatment of Singularities in a 4×4 Matrix Formalism, Phys. Rev. B 61, 1740 (2000). \n[7] Z.-M. Li, B. T. Sullivan, and R. R. Parsons, Use of the 4 × 4 Matrix Method in the Optics of Multilayer Magnetooptic Recording Media, Appl. Opt., AO 27, 1334 (1988). \n[8] P. Yeh, Electromagnetic Propagation in Birefringent Layered Media, J. Opt. Soc. Am. 69, 742 (1979). \n[9] D. W. Berreman, Optics in Stratified and Anisotropic Media: 4×4-Matrix Formulation, J. Opt. Soc. Am. 62, 502 (1972).","category":"section"},{"location":"#TransferMatrix.jl","page":"Introduction","title":"TransferMatrix.jl","text":"TransferMatrix.jl provides a general 4x4 transfer matrix method for optical waves propagating in layered media implemented in Julia. The core is an electrodynamics simulation based on a general 4x4 transfer matrix method developed by Passler, et al. Recent corrections and improvements are incorporated to deal with singularities and numerical instabilities for some types of multi-layered structures. Sources are cited both in the documentation and docstrings where appropriate. A comprehensive bibliography is also available as part of the documentation.\n\nThere are a lot of transfer matrix programs out there. Many are proprietary and some are part of graduate theses. The problem with the proprietary ones are that the source code cannot be examined  nor modified (and are not free). The problem with programs  written for papers are that they are rarely maintained, are not well documented, are not well tested, and are poorly organized. This makes it very difficult to use them. TransferMatrix.jl  solves these problems and provides the first generalized 4x4 transfer matrix algorithm available for Julia.\n\n<div style=\"text-align: center;\">\n<img src=\"assets/polariton_dispersion.png\" alt=\"polariton dispersion\", width=\"100%\"/>\n</div>","category":"section"},{"location":"#API","page":"Introduction","title":"API","text":"Only exported types and functions are considered part of the public API. All of these objects are documented in this manual. If not, please open an issue. The advanced user is encouraged, however, to access the guts of TransferMatrix.jl and modify portions to achieve a desired outcome or test a different approach to the algorithm. This implementation is as modular as possible to maximize flexibility; each function is as small as possible so that the user may easily change any step along the way in calculating the transfer matrix, reflection or transmission spectra, electric field profile, etc.","category":"section"},{"location":"#Issues-and-contributions","page":"Introduction","title":"Issues and contributions","text":"If you spot any errors or improvements to make, please open an issue and if you want to contribute consider making a pull request.","category":"section"},{"location":"guide/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"guide/tutorial/#Installation","page":"Tutorial","title":"Installation","text":"TransferMatrix.jl is a part of Julia's general registry and the source code can be found at https://github.com/garrekstemo/TransferMatrix.jl. From the Julia REPL, enter the package manager mode mode by typing ]. Then just enter the following to install the package:\n\npkg> add TransferMatrix","category":"section"},{"location":"guide/tutorial/#A-simple-calculation","page":"Tutorial","title":"A simple calculation","text":"To get up and running, let's build a simple two-layer structure of air and glass and calculate the reflectance and transmittance to visualize the Brewster angle for p-polarized light. We fix the wavelength of incident light and vary the angle of incidence.\n\nWe start by making a Layer of air and a Layer of glass. We'll do this for  a wavelength of 1 μm. Since there are only two layers and the transfer matrix method treats the first and last layers as semi-infinite, there is no need to provide a thickness for our glass and air layers. From the examples below, you can see that there are fields for\n\nthe material\nthe layer thickness\n\nThe material is a RefractiveMaterial from the RefractiveIndex.jl package. You can also initize a Layer with data for the refractive index and extinction coefficient.\n\nusing TransferMatrix\nusing RefractiveIndex\n\nn_air = RefractiveMaterial(\"other\", \"air\", \"Ciddor\")\nn_glass = RefractiveMaterial(\"glass\", \"soda-lime\", \"Rubin-clear\")[1]\nair = Layer(n_air, 0.1)\nglass = Layer(n_glass, 0.1)\nlayers = [air, glass];\n\nNow that we have our glass and air layers, we can iterate over the angles of incidence and compute the reflectance and transmittance for light of wavelength 1 μm.\n\nλ = 1.0\nθs = 0.0:1:85.0\nresult = sweep_angle([λ], deg2rad.(θs), layers; verbose=true);\n\nLet's now plot the result using the Makie.jl data visualization package.\n\nusing CairoMakie\n\nbrewster = atan(n_glass(λ)) * 180 / π\n\nf = Figure()\nax = Axis(f[1, 1], xlabel = \"Incidence Angle (°)\", ylabel = \"Reflectance / Transmittance\")\nlines!(θs, result.Tss[:, 1], label = \"Ts\", color = :firebrick3)\nlines!(θs, result.Tpp[:, 1], label = \"Tp\", color = :orangered3)\nlines!(θs, result.Rss[:, 1], label = \"Rs\", color = :dodgerblue4)\nlines!(θs, result.Rpp[:, 1], label = \"Rp\", color = :dodgerblue1)\nvlines!(brewster, color = :black, linestyle = :dash)\ntext!(35, 0.6, text = \"Brewster angle\\n(Rp = 0)\")\n\naxislegend(ax)\nf\n\nWe can see that the result of the angle-resolved calculation has four solutions: the s-wave and p-wave for both the reflected and transmitted waves. And we see that the Brewster angle is arctanleft( n_textglass n_textair right) approx 56^circ, as expected. Simultaneous calculation of s- and p-polarized incident waves is a feature of the  general 4x4 transfer matrix method being used. The sweep_angle function will also loop through all wavelengths so that you can plot a color plot of wavelength and angle versus transmittance (or reflectance).","category":"section"},{"location":"guide/tutorial/#A-simple-multi-layered-structure","page":"Tutorial","title":"A simple multi-layered structure","text":"Now that we can make Layers, we can put them together to calculate  the transfer matrix for a multi-layered structure and plot the reflectance and transmittance spectra. An important structure in optics is the Fabry-Pérot etalon, made with two parallel planar mirrors with a gap between them. If we set the optical path length to be an integer multiple of half the wavelength, we get constructive interference and a resonance in the transmittance spectrum. In the frequency domain, the cavity modes are evenly spaced by the free spectral range (FSR). We will scan in the mid infrared between 4 and 6 μm and use data generated via the Lorentz-Drude model for each 10 nm-thick gold mirror. (Note that we stay in units of micrometers for the wavelength.)\n\ncaf2 = RefractiveMaterial(\"main\", \"CaF2\", \"Malitson\")\nau = RefractiveMaterial(\"main\", \"Au\", \"Rakic-LD\")\nair = RefractiveMaterial(\"other\", \"air\", \"Ciddor\")\n\nλ_0 = 5.0\nt_middle = λ_0 / 2\nair = Layer(air, t_middle)\nau = Layer(au, 0.01)\nlayers = [air, au, air, au, air];\n\nλs = range(2.0, 6.0, length = 500)\nfrequencies = 10^4 ./ λs\n\nTp = Float64[]\nTs = Float64[]\nRp = Float64[]\nRs = Float64[]\nfor λ in λs\n    result = transfer(λ, layers)\n    push!(Tp, result.Tpp)\n    push!(Ts, result.Tss)\n    push!(Rp, result.Rpp)\n    push!(Rs, result.Rss)\nend\n\nf, ax, l = lines(frequencies, Ts)\nax.xlabel = \"Frequency (cm⁻¹)\"\nax.ylabel = \"Transmittance\"\nf","category":"section"},{"location":"guide/tutorial/#Electric-field-calculation","page":"Tutorial","title":"Electric field calculation","text":"The wavelength-dependent electric field is the cavity is provided by the efield function. We can calculate the electric field at the first peak in the above plot using\n\nλ_min = findfirst(λs .> 4.9)\nλ_max = findfirst(λs .> 5.5)\npeak = findmax(Ts[λ_min:λ_max])[2] + λ_min - 1\nλ = λs[peak]\n\nfield = efield(λ, layers)\n\nf, ax, l = lines(field.z .* 1e3, real(field.p[1, :]))\nvlines!(field.boundaries[1], color = :black, linestyle = :dash)\nvlines!(field.boundaries[end] .* 1e3, color = :black, linestyle = :dash)\nf","category":"section"},{"location":"guide/tutorial/#User-generated-refractive-index-data","page":"Tutorial","title":"User-generated refractive index data","text":"A convenience function is available to generate a Layer with user-generated refractive index data. For example, if we want to make an absorbing layer modeled on a Lorentzian function, we would\n\nGenerate the dielectric function for the absorbing material.\nCalculate the refractive index and extinction coefficient.\n\nbeginaligned\n   varepsilon_r(omega) = n_infty^2 + fracA (omega_0^2 - omega^2)(omega^2 - omega_0^2)^2 + (Gamma omega)^2 \n\n   varepsilon_i(omega) = fracA Gamma omega(omega^2 - omega_0^2)^2 + (Gamma omega)^2 \n\n   n(omega) = sqrtfracvarepsilon_r + sqrtvarepsilon_r^2 + varepsilon_i^22 \n\n   k(omega) = sqrtfrac-varepsilon_r + sqrtvarepsilon_r^2 + varepsilon_i^22 \nendaligned\n\nwhere A is the amplitude, omega_0 is the resonant frequency, Gamma is phenomenological damping, and n_infty is the background refractive index. Then this data, along with the wavelengths and thickness of the layer, can be used to create a Layer object. Under the hood, this data is converted into an interpolation function that, when given a wavelength, will return the complex refractive index. (Extrapolation is not supported right now.)\n\nfunction dielectric_real(ω, p)\n    A, ω_0, Γ = p\n    return @. A * (ω_0^2 - ω^2) / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)\nend\n\nfunction dielectric_imag(ω, p)\n    A, ω_0, Γ = p\n    return @. A * Γ * ω / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)\nend\n\n# absorbing material\nλ_0 = 5.0\nλs = range(4.8, 5.2, length = 200)\nfrequencies = 10^4 ./ λs\nn_bg = 1.4\nA_0 = 3000.0\nω_0 = 10^4 / λ_0  # cm^-1\nΓ_0 = 5\np0 = [A_0, ω_0, Γ_0]\nε1 = dielectric_real(frequencies, p0) .+ n_bg^2\nε2 = dielectric_imag(frequencies, p0)\nn_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) + ε1) / 2)\nk_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) - ε1) / 2)\n\nabsorber = Layer(λs, n_medium, k_medium, t_cav)\nabsorber.dispersion(4.9)\n\nA complete example calculating dispersion of a polaritonic system is provided in the examples folder of the package source code.","category":"section"},{"location":"guide/tutorial/#Thickness-dependent-calculations","page":"Tutorial","title":"Thickness-dependent calculations","text":"Similar to sweep_angle, you can vary the thickness of a particular layer using sweep_thickness. You specify which layer to vary by its index in the layers array.\n\nλs = range(0.8, 1.2, length=100)\nthicknesses = range(0.3, 0.7, length=100)\n\n# Vary layer 9 (the cavity air gap)\nres = sweep_thickness(λs, thicknesses, layers, 9)\n\nheatmap(thicknesses, λs, res.Tpp')\n\n(Image: Thickness dependence)\n\nA complete example is provided in the examples folder of the package source code.","category":"section"}]
}
