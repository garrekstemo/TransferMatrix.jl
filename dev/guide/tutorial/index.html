<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · TransferMatrix.jl</title><meta name="title" content="Tutorial · TransferMatrix.jl"/><meta property="og:title" content="Tutorial · TransferMatrix.jl"/><meta property="twitter:title" content="Tutorial · TransferMatrix.jl"/><meta name="description" content="Documentation for TransferMatrix.jl."/><meta property="og:description" content="Documentation for TransferMatrix.jl."/><meta property="twitter:description" content="Documentation for TransferMatrix.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TransferMatrix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#A-simple-calculation"><span>A simple calculation</span></a></li><li><a class="tocitem" href="#Defining-a-Layer"><span>Defining a Layer</span></a></li><li><a class="tocitem" href="#A-simple-multi-layered-structure"><span>A simple multi-layered structure</span></a></li><li><a class="tocitem" href="#Polariton-dispersion-in-a-DBR-cavity"><span>Polariton dispersion in a DBR cavity</span></a></li><li><a class="tocitem" href="#Periodic-structures-with-a-YAML-config-file"><span>Periodic structures with a YAML config file</span></a></li><li><a class="tocitem" href="#Electric-field"><span>Electric field</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/garrekstemo/TransferMatrix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/garrekstemo/TransferMatrix.jl/blob/main/docs/src/guide/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>TransferMatrix.jl is a part of Julia&#39;s general registry and the source code can be found at <a href="https://github.com/garrekstemo/TransferMatrix.jl">https://github.com/garrekstemo/TransferMatrix.jl</a>. From the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">Julia REPL</a>, enter the package manager mode mode by typing <code>]</code>. Then just enter the following to install the package:</p><pre><code class="nohighlight hljs">pkg&gt; add TransferMatrix</code></pre><h2 id="A-simple-calculation"><a class="docs-heading-anchor" href="#A-simple-calculation">A simple calculation</a><a id="A-simple-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-calculation" title="Permalink"></a></h2><p>To get you up and running, let&#39;s build a simple two-layer structure of air and glass and calculate the reflectance and transmittance to visualize the <a href="https://en.wikipedia.org/wiki/Brewster%27s_angle">Brewster angle</a> for p-polarized light. We fix the wavelength of incident light and vary the angle of incidence when setting up our <code>Structure</code>. (It is just as simple to fix the incidence angle and calculate the transfer matrix as a function of the field wavelength.)</p><p>We start by making a <code>Layer</code> type of air and a <code>Layer</code> of glass. We&#39;ll do this for  a wavelength of 1 μm. Since there are only two layers and the transfer matrix method treats the first and last layers as semi-infinite, there is no need to provide a thickness for our glass and air layers. From the examples below, you can see that there are fields for</p><ul><li>the material name</li><li>the layer thickness</li><li>a list of wavelengths</li><li>the real part of the refractive index (corresponding to the wavelength)</li><li>the imaginary part of the refractive index</li></ul><p>Details about different ways to make a layer are further on in the tutorial.</p><pre><code class="language-julia hljs">using TransferMatrix

air = Layer(&quot;Air&quot;, 0.0, [1.0e-6], [1.0], [0.0])
glass = Layer(&quot;Glass&quot;, 0.0, [1.0e-6], [1.5], [0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Layer(&quot;Glass&quot;, 0.0, [1.0e-6], [1.5], [0.0])</code></pre><h3 id="Assembling-layers-into-a-structure"><a class="docs-heading-anchor" href="#Assembling-layers-into-a-structure">Assembling layers into a structure</a><a id="Assembling-layers-into-a-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-layers-into-a-structure" title="Permalink"></a></h3><p>Now that we have our glass and air layers, we need to assemble them into a structure and provide the angles of the field with respect to the surface of the structure. We do this with the <code>Structure</code> type.</p><pre><code class="language-julia hljs">θs = range(0.0, 85.0, length = 500)
s = Structure([air, glass], [1e-6], collect(θs) .* π/180)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure(Layer[Layer(&quot;Air&quot;, 0.0, [1.0e-6], [1.0], [0.0]), Layer(&quot;Glass&quot;, 0.0, [1.0e-6], [1.5], [0.0])], [1.0e-6], [0.0, 0.0029730057398701004, 0.005946011479740201, 0.0089190172196103, 0.011892022959480402, 0.0148650286993505, 0.0178380344392206, 0.020811040179090703, 0.023784045918960803, 0.026757051658830907  …  1.4567728125363493, 1.459745818276219, 1.4627188240160895, 1.4656918297559594, 1.4686648354958296, 1.4716378412356999, 1.4746108469755699, 1.47758385271544, 1.48055685845531, 1.4835298641951802])</code></pre><p>The first argument is just a list of layers. The second argument is a list of desired wavelengths. Often the refractive index data we have for  two materials are not given for exactly the same wavelengths.  TransferMatrix.jl uses an interpolation function to normalize the wavelengths and complex refractive indices for all layers from  this user-provided list of wavelengths. (Be careful if the range you provide goes beyond the range of the data that you have!) Now we can evaluate the angle-resolved spectrum using the function <code>angle_resolved()</code>.</p><pre><code class="language-julia hljs">res = angle_resolved(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransferMatrix.AngleResolvedResult([0.04000000000000003; 0.039999528598952526; … ; 0.4813707135624852; 0.4932538118188537;;], [0.04000000000000003; 0.04000047140359379; … ; 0.7246514855242108; 0.7323454787108021;;], [0.9600000000000001; 0.9600004714010474; … ; 0.5186292864375149; 0.5067461881811459;;], [0.9600000000000001; 0.9599995285964057; … ; 0.2753485144757894; 0.267654521289198;;], Matrix{ComplexF64}[], ComplexF64[0.0 + 0.0im; 0.00297300136025645 + 0.0im; … ; 0.9959311813887618 + 0.0im; 0.9961946980917455 + 0.0im;;])</code></pre><p>Let&#39;s also plot the result using the <a href="https://makie.juliaplots.org/">Makie.jl</a> data visualization package.</p><pre><code class="language-julia hljs">using CairoMakie

brewster = atan(1.5) * 180 / π

f = Figure()
ax = Axis(f[1, 1], xlabel = &quot;Incidence Angle (°)&quot;, ylabel = &quot;Reflectance / Transmittance&quot;)

lines!(θs, res.Tss[:, 1], color = :firebrick4, label = &quot;Ts&quot;)
lines!(θs, res.Tpp[:, 1], color = :orangered3, label = &quot;Tp&quot;)
lines!(θs, res.Rss[:, 1], color = :dodgerblue4, label = &quot;Rs&quot;)
lines!(θs, res.Rpp[:, 1], color = :dodgerblue1, label = &quot;Rp&quot;)
vlines!(brewster, color = :dodgerblue1, linestyle = :dash)
text!(&quot;Brewster angle\n(Rp = 0)&quot;, position = (35, 0.6))

axislegend(ax)
f</code></pre><img src="9f208820.png" alt="Example block output"/><p>We can see that the result of the angle-resolved calculation has four solutions: the s-wave and p-wave for both the reflected and transmitted waves. And we see that the Brewster angle is <span>$\arctan\left( n_\text{glass} /n_\text{air} \right) \approx 56^{\circ}$</span>, as expected. Simultaneous calculation of s- and p-polarized incident waves is a feature of the  general 4x4 transfer matrix method being used. The <code>angle_resolved</code> function will also loop through all wavelengths so that you can plot a color plot of wavelength and angle versus transmittance (or reflectance).</p><h2 id="Defining-a-Layer"><a class="docs-heading-anchor" href="#Defining-a-Layer">Defining a Layer</a><a id="Defining-a-Layer-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Layer" title="Permalink"></a></h2><p>The <code>Layer</code> type is immutable. Once you make one, you can&#39;t change any of its  characteristics later. There are two ways to define a <code>Layer</code>. The first is by  directly filling in the argument fields:</p><pre><code class="language-julia hljs">Layer(material, thickness, λs, ns, κs)</code></pre><p>You may choose any units you like for thickness and wavelength,  but they must be the same (e.g. both are in nanometers). The material is just a <code>String</code>. Wavelength, and the  refractive index arguments must be Arrays, even if they just contain  with a single item. A very manual way to make a <code>Layer</code> might look like this:</p><pre><code class="language-julia hljs">glass = Layer(&quot;Glass&quot;, 20.0e-6, [1.0e-6, 1.1e-6, 1.3e-6], [0.0, 0.0, 0.0])</code></pre><p>This way works well for simple <code>Layers</code> or when you just need a single frequency for an angle-resolved calculation, but this is a lot more work if the refractive index  is pulled from a database or a file. The website <a href="https://refractiveindex.info">refractiveindex.info</a> contains a large database of refractive indices from peer-reviewed papers. TransferMatrix.jl makes it easy to use a CSV file downloaded from this website with the <code>read_refractive()</code> function, which returns a <code>Layer</code> type. You can choose  to include (or not) the real/imaginary part of the complex refractive index. Note that  this refractiveindex.info stores wavelength information in units of micrometers.</p><pre><code class="language-julia hljs">glass = read_refractive(&quot;/path/to/file.csv&quot;, &quot;Glass&quot;, 20e-6, div=1e6)</code></pre><p>The <code>div</code> keyword argument at the end of <code>read_refractive</code> represents the  desired unit conversion. In this case, if we want everything to be in meters we must divide each wavelength in the raw data by <span>$10^6$</span>. Alternatively, we can  change the thickness units to micrometers. Just be careful that all <code>Layer</code>s in your multi-layered structure have consistent units.</p><p>The <code>Layer</code> properties can be independently queried. To get the material name or thickness,  for example, you can just type:</p><pre><code class="language-julia hljs">julia&gt; glass.material
&quot;Glass&quot;
julia&gt; glass.thickness
2.0e-5</code></pre><p>The same can be done to get wavelengths (<code>glass.λ</code>) (get λ by typing <code>\lambda</code>), real refractive index (<code>glass.n</code>), and complex refractive index (<code>glass.κ</code>) (get κ by typing <code>\kappa</code>). (A very useful feature of Julia is built-in support for unicode characters).</p><h2 id="A-simple-multi-layered-structure"><a class="docs-heading-anchor" href="#A-simple-multi-layered-structure">A simple multi-layered structure</a><a id="A-simple-multi-layered-structure-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-multi-layered-structure" title="Permalink"></a></h2><p>Now that we can make <code>Layer</code>s, we can put them together to calculate  the transfer matrix for a multi-layered structure and plot the reflectance and transmittance spectra. A very important structure in optics is the Fabry-Pérot etalon, which can be made with two mirrors that face each other with a gap between them. Let&#39;s make this a  little more challenging (and experimentally realistic) by  mounting the mirrors onto windows that are transparent in our chosen wavelength range. The gap will simply be 20 μm of air. We will scan in the mid infrared between 4 and 6 μm and use data generated via the <a href="https://en.wikipedia.org/wiki/Lorentz_oscillator_model">Lorentz-Drude model</a> for each 10 nm-thick gold layer and experimental data from Malitson, 1963 for the windows. (Some example refractive index data are in the <code>refractive_index_data</code> folder in the simulation <code>src</code> directory. The <code>../</code> syntax denotes a relative file path one level up from the current folder.)</p><pre><code class="language-julia hljs">λs = range(4.0, 6.0, length = 1000) .* 1e-6
aufile = &quot;../../../../refractive_index_data/Au_nk_0.248-6.20um_Lorentz-Drude_Rakic1998.csv&quot;
caf2file = &quot;../../../../refractive_index_data/CaF2_n_0.23-9.7um_Malitson.csv&quot;

air = Layer(&quot;Air&quot;, 20e-6, collect(λs), fill(1.0, length(λs)), zeros(length(λs)))
au = read_refractive(aufile, &quot;Au&quot;, 10e-9, div=1e6)
caf2 = read_refractive(caf2file, &quot;CaF2&quot;, 5.0e-6, div=1e6)

s = Structure([caf2, au, air, au, caf2], collect(λs), [0.0])
Tp, Ts, Rp, Rs = calculate_tr(s)

f, ax, l = lines(λs .* 1e6, Ts)
ax.xlabel = &quot;Wavelength&quot;
ax.ylabel = &quot;Transmittance&quot;
f</code></pre><img src="077c4253.png" alt="Example block output"/><p>It is easy to combine manually-generated data and experimental data to calculate the global transfer matrix.</p><h2 id="Polariton-dispersion-in-a-DBR-cavity"><a class="docs-heading-anchor" href="#Polariton-dispersion-in-a-DBR-cavity">Polariton dispersion in a DBR cavity</a><a id="Polariton-dispersion-in-a-DBR-cavity-1"></a><a class="docs-heading-anchor-permalink" href="#Polariton-dispersion-in-a-DBR-cavity" title="Permalink"></a></h2><p>Now let&#39;s try something a little more complicated. We will simulate an absorbing material with a resonance that coincides with a cavity mode resonance at some angle. We will calculate the system dispersion and plot the transmittance spectrum as a function of incidence angle. Then we will plot the electric field profile within the structure. First we need to define the dielectric function of the absorbing material. The real and imagary parts of the dielectric function can be defined as below:</p><pre><code class="language-julia hljs">function dielectric_real(ω, p)
    A, ω_0, Γ = p
    return @. A * (ω_0^2 - ω^2) / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)
end
function dielectric_imag(ω, p)
    A, ω_0, Γ = p
    return @. A * Γ * ω / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">dielectric_imag (generic function with 1 method)</code></pre><p>The center wavelength for the absorbing material will be 5 μm, so we set the wavelength region centered around this and define quarter-wavelength materials for the DBR in terms of this wavelength. The refractive indices for these materials are arbitrary and, for this example, are not wavelength-dependent (although they usually are). We will make the optical path length of the cavity region slightly greater than one wavelength to get a negative detuning between the cavity resonance and the absorbing material resonance at normal incidence (i.e. <span>$\Delta = |\omega_c - \omega_m| &lt; 0$</span>).</p><pre><code class="language-julia hljs">λ_center = 5e-6
λs = collect(range(4.8, 5.2, length = 300)) .* 1e-6
θs = collect(range(0, 30, length = 100))  # degrees
νs = 10^-2 ./ λs
n1 = 2.1
n2 = 1.6
n_bg = 1.4  # Background refractive index

# Layer thicknesses
t1 = λ_center / (4 * n1[1])
t2 = λ_center / (4 * n2[1])
t_cav = 1 * λ_center  / n_bg + 0.1e-6  # Slightly offset the cavity length to get negative detuning</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.6714285714285717e-6</code></pre><p>Now we can define the absorbing material. The amplitude of the resonance is arbitrary and is set to 5000. The width of the resonance is set to 5 cm^-1. The real and imaginary parts of the dielectric function are used to calculate the refractive index <code>n</code> and extinction coefficient <code>k</code>, which are used to define the <code>lorentzian</code> layer. Since the dielectric function is unitless, we can perform these calculations in reciprocal centimeters without affecting the transfer matrix calculation, which will be done in units of micrometers.</p><pre><code class="language-julia hljs">A_0 = 5000.0
ω_0 = 10^-2 / λ_center
Γ_0 = 5
p0 = [A_0, ω_0, Γ_0]
ε1 = dielectric_real(νs, p0) .+ n_bg^2
ε2 = dielectric_imag(νs, p0)
n_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) + ε1) / 2)
k_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) - ε1) / 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300-element Vector{Float64}:
 0.00016110139215916766
 0.00016337265900263461
 0.00016569095774527474
 0.00016805758699204028
 0.0001704738891576009
 0.00017294125393486166
 0.0001754611195905365
 0.00017803497601524403
 0.0001806643650261984
 0.0001833508845284868
 ⋮
 0.0002084467398187206
 0.0002056456260517088
 0.00020290195673241631
 0.00020021416332229914
 0.00019758072961916317
 0.00019500019196557218
 0.00019247113481031365
 0.00018999218939238922
 0.00018756203350112427</code></pre><p>Now we can define the layers of the system. For the DBR mirrors, we set the number of periods of alternating materials to 6 for high reflectivity in the region of interest.  The thickness of the two outer layers (air) is arbitrary and does not affect the result.</p><pre><code class="language-julia hljs">air = Layer(&quot;Air&quot;, 0.5e-6, λs, fill(1.0, length(λs)), zeros(length(λs)))
material1 = Layer(&quot;Material 1&quot;, t1, λs, fill(n1, length(λs)), zeros(length(λs)))
material2 = Layer(&quot;Material 2&quot;, t2, λs, fill(n2, length(λs)), zeros(length(λs)))
lorentzian = Layer(&quot;Lorentz oscillator&quot;, t_cav, λs, n_medium, k_medium)
nperiods = 6
unit = [material1, material2]
layers = [air, repeat(unit, nperiods)..., lorentzian, repeat(reverse(unit), nperiods)..., air]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">27-element Vector{Layer}:
 Layer(&quot;Air&quot;, 5.0e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 ⋮
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 2&quot;, 7.8125e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6  …  1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6, 1.6], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Material 1&quot;, 5.952380952380953e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1  …  2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1, 2.1], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
 Layer(&quot;Air&quot;, 5.0e-7, [4.8e-6, 4.801337792642141e-6, 4.802675585284281e-6, 4.804013377926421e-6, 4.805351170568562e-6, 4.806688963210703e-6, 4.808026755852842e-6, 4.809364548494983e-6, 4.810702341137124e-6, 4.812040133779265e-6  …  5.187959866220735e-6, 5.189297658862876e-6, 5.190635451505017e-6, 5.191973244147157e-6, 5.193311036789297e-6, 5.194648829431438e-6, 5.195986622073578e-6, 5.197324414715718e-6, 5.198662207357859e-6, 5.2e-6], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])</code></pre><p>After we calculate the angle-dependent transmittance and reflectance, there will be a normal mode splitting as a resulting of the coupling between the cavity mode and the absorbing material resonance. We want to find the angle at which the amplitudes of the two modes are equal, so define the function below using the <code>Peaks.jl</code> package to do this.</p><pre><code class="language-julia hljs">using Peaks

function find_resonance(s, atol=1e-3)
    for i in eachindex(s.θ)
        pks, vals = findmaxima(res.Tpp[i, :])
        if length(pks) == 2 &amp;&amp; isapprox(vals[1], vals[2], atol=atol)
            return i, pks
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">find_resonance (generic function with 2 methods)</code></pre><p>Now we can calculate the transmittance and reflectance spectra, find the resonance angle, and calculate the electric field at both peaks.</p><pre><code class="language-julia hljs">s = Structure(layers, λs, deg2rad.(θs))
res = angle_resolved(s)
angle_idx, peaks = find_resonance(s, 1e-2)

θ_plot = round(rad2deg(s.θ[angle_idx]), digits=1)
T_plot = res.Tpp[angle_idx, :]
field1 = electric_field(s, s.λ[peaks[1]])
field2 = electric_field(s, s.λ[peaks[2]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TransferMatrix.ElectricField([-5.0e-7, -4.787895037895038e-7, -4.575790075790076e-7, -4.3636851136851135e-7, -4.1515801515801513e-7, -3.939475189475189e-7, -3.7273702273702273e-7, -3.515265265265265e-7, -3.303160303160303e-7, -3.091055341055341e-7  …  2.049839124839125e-5, 2.0519601744601746e-5, 2.054081224081224e-5, 2.0562022737022738e-5, 2.0583233233233233e-5, 2.060444372944373e-5, 2.0625654225654225e-5, 2.0646864721864722e-5, 2.0668075218075217e-5, 2.0689285714285714e-5], ComplexF64[-0.062142225663579076 - 0.8379755623392602im -0.05338580137471283 - 0.793089016850737im … -0.033608178054107214 + 0.3003313882053041im -0.041542019194197144 + 0.29933712268061674im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im], ComplexF64[0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; -0.062142225663579076 - 0.8379755623392602im -0.05338580137471283 - 0.793089016850737im … -0.033608178054107214 + 0.3003313882053041im -0.041542019194197144 + 0.29933712268061674im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im], [0.0, 5.952380952380954e-7, 1.3764880952380954e-6, 1.971726190476191e-6, 2.752976190476191e-6, 3.348214285714286e-6, 4.129464285714286e-6, 4.724702380952381e-6, 5.505952380952382e-6, 6.101190476190477e-6  …  1.4088095238095242e-5, 1.4683333333333337e-5, 1.5464583333333338e-5, 1.6059821428571433e-5, 1.6841071428571432e-5, 1.7436309523809527e-5, 1.8217559523809526e-5, 1.881279761904762e-5, 1.959404761904762e-5, 2.0189285714285716e-5])</code></pre><p>Then we plot the dispersion curve, the transmittance spectrum at zero detuning, and the electric field profiles at the two peaks. Finally, we plot the refractive index profile of the structure as a function of position and display this below the field profile to see the behavior of the field at different points in the structure.</p><pre><code class="language-julia hljs">fig = Figure()
ax = Axis(fig[1, 1], title=&quot;Polariton dispersion&quot;, xlabel = &quot;Incidence angle (°)&quot;, ylabel = &quot;Frequency (cm⁻¹)&quot;)
heatmap!(θs, νs, res.Tpp, colormap = :deep)
fig</code></pre><img src="121bdf4c.png" alt="Example block output"/><pre><code class="language-julia hljs">fig = Figure()

ax = Axis(fig[1, 1], title=&quot;Normal mode splitting (θ ≈ $θ_plot °)&quot;, xlabel = &quot;Frequency  (cm⁻¹)&quot;, ylabel = &quot;Transmittance&quot;)
lines!(νs, 4π .* k_medium .* νs ./ 1e4, color = :firebrick3, linestyle = :dash, label = &quot;Abs&quot;)
lines!(νs, T_plot, label = &quot;T&quot;)
scatter!(νs[peaks], T_plot[peaks], color = :red, marker = &#39;x&#39;, markersize = 15)
axislegend(ax)
fig</code></pre><img src="28006cf8.png" alt="Example block output"/><p>We will use the following function to draw the refractive index profile of the structure.</p><pre><code class="language-julia hljs">function draw_index_profile(ax, indices, thicknesses)
    prev_x = 0
    prev_n = indices[1]
    for (i, n) in enumerate(indices)
        current_x = sum(thicknesses[1:i])
        lines!(ax, [prev_x, current_x], [n, n], color = :black, linewidth = 0.5)  # Plot the horizontal line
        if i &gt; 1
            lines!(ax, [prev_x, prev_x], [prev_n, n], color = :black, linewidth = 0.5)  # Plot the vertical line
        end
        prev_x = current_x
        prev_n = n
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">draw_index_profile (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">fig = Figure()

ax1 = Axis(fig[1, 1], ylabel = &quot;Photon field&quot;)
lines!(field1.z .* 1e6, real(field1.p[1, :]), label = &quot;LP&quot;)
lines!(field2.z .* 1e6, real(field2.p[1, :]), label = &quot;UP&quot;)
hlines!(0, color = :black, linestyle = :dash, linewidth = 0.5)

ax2 = Axis(fig[2, 1], xlabel = &quot;Distance (μm)&quot;, ylabel = &quot;Refractive index&quot;, xticks = LinearTicks(7), yticks = [n1, n2])

# Draw DBR cavity structure
refractive_indices = [layer.n[1] for layer in layers[2:end-1]]
thicknesses = [layer.thickness for layer in layers[2:end-1]] .* 1e6

draw_index_profile(ax2, refractive_indices, thicknesses)

axislegend(ax1)
hidexdecorations!(ax1)
hideydecorations!(ax1, label = false, ticks = false, ticklabels = false)
hidexdecorations!(ax2, label = false, ticks = false, ticklabels = false)
hideydecorations!(ax2, label = false)
rowgap!(fig.layout, 1, 0)

fig</code></pre><img src="04874373.png" alt="Example block output"/><p>The electric field amplitude at both peaks is different because of the oblique incidence angle.</p><p>Here is the code to reproduce this example in its entirety:</p><pre><code class="language-julia hljs">using TransferMatrix
using Peaks
using CairoMakie

function dielectric_real(ω, p)
    A, ω_0, Γ = p
    return @. A * (ω_0^2 - ω^2) / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)
end
function dielectric_imag(ω, p)
    A, ω_0, Γ = p
    return @. A * Γ * ω / ((ω^2 - ω_0^2)^2 + (Γ * ω)^2)
end

function find_resonance(s, atol=1e-3)
    for i in eachindex(s.θ)
        pks, vals = findmaxima(res.Tpp[i, :])
        if length(pks) == 2 &amp;&amp; isapprox(vals[1], vals[2], atol=atol)
            return i, pks
        end
    end
end

λ_center = 5e-6
λs = collect(range(4.8, 5.2, length = 300)) .* 1e-6
θs = collect(range(0, 30, length = 100))  # degrees
νs = 10^-2 ./ λs
n1 = 2.1  
n2 = 1.6
n_bg = 1.4  # Background refractive index

# Layer thicknesses
t1 = λ_center / (4 * n1[1])
t2 = λ_center / (4 * n2[1])
t_cav = 1 * λ_center  / n_bg + 0.1e-6  # Slightly offset the cavity length to get negative detuning

# Define the dielectric function inside the cavity
A_0 = 5000.0
ω_0 = 10^-2 / λ_center
Γ_0 = 5
p0 = [A_0, ω_0, Γ_0]
ε1 = dielectric_real(νs, p0) .+ n_bg^2
ε2 = dielectric_imag(νs, p0)
n_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) + ε1) / 2)
k_medium = @. sqrt((sqrt(abs2(ε1) + abs2(ε2)) - ε1) / 2)

# Define the layers
air = Layer(&quot;Air&quot;, 0.5e-6, λs, fill(1.0, length(λs)), zeros(length(λs)))
material1 = Layer(&quot;Material 1&quot;, t1, λs, fill(n1, length(λs)), zeros(length(λs)))
material2 = Layer(&quot;Material 2&quot;, t2, λs, fill(n2, length(λs)), zeros(length(λs)))
lorentzian = Layer(&quot;Lorentz oscillator&quot;, t_cav, λs, n_medium, k_medium)
nperiods = 6
unit = [material1, material2]
layers = [air, repeat(unit, nperiods)..., lorentzian, repeat(reverse(unit), nperiods)..., air]

# Calculate the transmittance, reflectance
s = Structure(layers, λs, deg2rad.(θs))
res = angle_resolved(s)
angle_idx, peaks = find_resonance(s, 1e-2)

θ_plot = round(rad2deg(s.θ[angle_idx]), digits=1)
T_plot = res.Tpp[angle_idx, :]
field1 = electric_field(s, s.λ[peaks[1]])
field2 = electric_field(s, s.λ[peaks[2]])


fig = Figure(size = (400, 1000))

ax1 = Axis(fig[1, 1], title=&quot;Polariton dispersion&quot;, xlabel = &quot;Incidence angle (°)&quot;, ylabel = &quot;Frequency (cm⁻¹)&quot;)
heatmap!(θs, νs, res.Tpp, colormap = :deep)

ax2 = Axis(fig[2, 1], title=&quot;Normal mode splitting (θ ≈ $θ_plot °)&quot;, xlabel = &quot;Frequency  (cm⁻¹)&quot;, ylabel = &quot;Transmittance&quot;)
lines!(νs, 4π .* k_medium .* νs ./ 1e4, color = :firebrick3, linestyle = :dash, label = &quot;Abs&quot;)
lines!(νs, T_plot, label = &quot;T&quot;)
scatter!(νs[peaks], T_plot[peaks], color = :red, marker = &#39;x&#39;, markersize = 15)

ax3 = Axis(fig[3, 1], ylabel = &quot;Photon field&quot;)
lines!(field1.z .* 1e6, real(field1.p[1, :]), label = &quot;LP&quot;)
lines!(field2.z .* 1e6, real(field2.p[1, :]), label = &quot;UP&quot;)
hlines!(0, color = :black, linestyle = :dash, linewidth = 0.5)

ax4 = Axis(fig[4, 1], xlabel = &quot;Distance (μm)&quot;, ylabel = &quot;Refractive index&quot;, xticks = LinearTicks(7), yticks = [n1, n2])

# Draw DBR cavity structure
refractive_indices = [layer.n[1] for layer in layers[2:end-1]]
thicknesses = [layer.thickness for layer in layers[2:end-1]] .* 1e6

prev_x = 0
prev_n = refractive_indices[1]
for (i, n) in enumerate(refractive_indices)
    current_x = sum(thicknesses[1:i])
    lines!(ax4, [prev_x, current_x], [n, n], color = :black, linewidth = 0.5)  # Plot the horizontal line

    if i &gt; 1
        lines!(ax4, [prev_x, prev_x], [prev_n, n], color = :black, linewidth = 0.5)  # Plot the vertical line
    end
    prev_x = current_x
    prev_n = n
end

# Draw a rectangle in the cavity region
middle_i = sum(thicknesses[1:length(thicknesses) ÷ 2])
middle_f = sum(thicknesses[1:length(thicknesses) ÷ 2 + 1])
poly!(ax4, Point2f[(middle_i, n_bg), (middle_f, n_bg), (middle_f, n1), (middle_i, n1)], color = (:deepskyblue2, 0.2))

# Formatting
ylims!(ax1, 1950, 2070)
axislegend(ax2)
axislegend(ax3)
hidexdecorations!(ax3)
hideydecorations!(ax3, label = false, ticks = false, ticklabels = false)
hidexdecorations!(ax4, label = false, ticks = false, ticklabels = false)
hideydecorations!(ax4, label = false)
rowgap!(fig.layout, 3, 0)

fig</code></pre><h2 id="Periodic-structures-with-a-YAML-config-file"><a class="docs-heading-anchor" href="#Periodic-structures-with-a-YAML-config-file">Periodic structures with a YAML config file</a><a id="Periodic-structures-with-a-YAML-config-file-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-structures-with-a-YAML-config-file" title="Permalink"></a></h2><p>With the tools described above, it is pretty easy to make any kind of multi-layered structure that you want. A very large structure, maybe one with repeating layers, is also not difficult to build. However, it would be useful to be able to load a  structure from a set of parameters so that it can be saved or even shared with others for better reproducibility. To do this, a <code>Structure</code> can be loaded directly from a YAML file (using <a href="https://github.com/JuliaData/YAML.jl">YAML.jl</a>). </p><p>Let&#39;s demonstrate this with a <a href="https://en.wikipedia.org/wiki/Distributed_Bragg_reflector">quarter-wave stack</a>, which is a periodic structure with two alternative layers where the thickness is one fourth of the wavelength within the medium, or the relation</p><p class="math-container">\[d_i = \frac{\lambda}{4n_i},\]</p><p>where <span>$d_i$</span> is the thickness for layer <span>$i$</span>, <span>$\lambda$</span> is the electric field wavelength in vacuum, and <span>$n_i$</span> is the index of refraction for layer <span>$i$</span>.</p><p>Here is the YAML file that gives us this:</p><pre><code class="nohighlight hljs"># All units in micrometers

min_wavelength: 0.5
max_wavelength: 2.0
n_wavelengths: 1000

# Theta in radians
theta_i: 0.0
theta_f: 0.0
n_theta: 1

layers:

    layer1:
        material: Air
        thickness: 0.5
        wavelength: 1.0
        refractive_index: 1.0
        extinction_coeff: 0.0

    layer2:
        periods: 3
        layers:
          layer1:
            material: &quot;ZnS n=2.32&quot;
            thickness: 0.1077
            refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv
          layer2:
            material: &quot;MgF2 n=1.36&quot;
            thickness: 0.1838
            refractive_filename: MgF2_nk_0.03-2.0um_Rodriguez2017.csv

    layer3: 
        material: &quot;ZnS n=2.32&quot;
        thickness: 0.1838
        refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv</code></pre><p>At the top, we set the minimum and maximum wavelengths to be calculated, with the  total number of points set to 1000. We won&#39;t do an angle-resolved calculation, so initial and final <span>$\theta$</span> are zero (with <code>n_theta</code> just one). Next the multi-layered structure is defined under <code>layers:</code>. The first layer is just air, so we don&#39;t need a file for this and can set the refractive index for a single wavelength. These values and wavelength are expanded when the YAML file is loaded. The final layer (<code>layer3</code>) is zinc sulfide (ZnS), which is loaded from a CSV file downloaded from <a href="https://refractiveindex.info">refractiveindex.info</a>. The middle section (<code>layer2</code>) is where we define the periodic structure. The first item determines how many periods we want. In this case, <code>periods: 3</code>. Then we  set the layers that alternate under another <code>layers</code> section. You can see that the first layer <code>layer1</code> is zinc sulfide and the second layer <code>layer2</code> is magnesium fluoride (MgF₂). The number of times that these two layers are repeated can easily be changed by editing the <code>periods</code> field. You can even have multiple repeating structures within the global structure for arbitrarily complicated structures.</p><p>To load the YAML config file into a <code>Structure</code>, we use the <code>load_from_yaml()</code> function. You can find this example in the <code>default_config</code> folder in the <code>quarter-wave.yaml</code> file.</p><pre><code class="language-julia hljs">s = load_from_yaml(abspath(&quot;../../../default_config/quarter-wave.yaml&quot;), 1e-6)
Tp, Ts, Rp, Rs = calculate_tr(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.9130563098195978, 0.9029002689472558, 0.8926804707814351, 0.8826271417027922, 0.8729449221143134, 0.863814941698935, 0.8553728415067637, 0.8477399728437076, 0.8410130207024722, 0.8352772978673564  …  0.8580061039350702, 0.8588749011786784, 0.859743674915508, 0.8606123664190505, 0.8614809171863055, 0.862349247057643, 0.863217315621725, 0.8640850689508629, 0.8649524494734356, 0.8658193998566369], [0.9130563098195978, 0.9029002689472558, 0.8926804707814351, 0.8826271417027922, 0.8729449221143134, 0.863814941698935, 0.8553728415067637, 0.8477399728437076, 0.8410130207024722, 0.8352772978673564  …  0.8580061039350702, 0.8588749011786784, 0.859743674915508, 0.8606123664190505, 0.8614809171863055, 0.862349247057643, 0.863217315621725, 0.8640850689508629, 0.8649524494734356, 0.8658193998566369], [0.07738850881115539, 0.08767249740770969, 0.09802099094735575, 0.10820161347294284, 0.1180088042284185, 0.12726665774657298, 0.13582461972538507, 0.1435627549446024, 0.1503868114592622, 0.15621076026724637  …  0.14157676668653815, 0.14070839627869383, 0.13984004986029905, 0.13897178617577155, 0.13810366374575572, 0.1372357615039273, 0.13636812090021944, 0.1355007961012557, 0.13463384469529158, 0.13376732403151376], [0.07738850881115539, 0.08767249740770969, 0.09802099094735575, 0.10820161347294284, 0.1180088042284185, 0.12726665774657298, 0.13582461972538507, 0.1435627549446024, 0.1503868114592622, 0.15621076026724637  …  0.14157676668653815, 0.14070839627869383, 0.13984004986029905, 0.13897178617577155, 0.13810366374575572, 0.1372357615039273, 0.13636812090021944, 0.1355007961012557, 0.13463384469529158, 0.13376732403151376])</code></pre><p>This particular example is taken from Pochi Yeh&#39;s <a href="https://www.wiley.com/en-us/Optical+Waves+in+Layered+Media-p-9780471731924"><em>Optical Waves in Layered Media</em></a> on page 110. You can find the reflectivity of this structure in Table 5.1. The values we have calculated are slightly different since the data used here is slightly dispersive with wavelength, but the example in the book takes flat refractive index values. You can try plotting this structure for an increasing number of periods and observe how the reflectance near <span>$\lambda$</span> = 1 μm increases.</p><pre><code class="language-julia hljs">using CairoMakie

f = Figure()
ax = Axis(f[1, 1], title = &quot;ZnS / MgF quarter-wave with 3 layers&quot;, xlabel = &quot;Wavelength (nm)&quot;, ylabel = &quot;Transmittance / Reflectance&quot;)

lines!(s.λ .* 1e9, Tp, label = &quot;T&quot;)
lines!(s.λ .* 1e9, Rp, label = &quot;R&quot;)
axislegend(ax, position = :rc)

f</code></pre><img src="286c80f9.png" alt="Example block output"/><h2 id="Electric-field"><a class="docs-heading-anchor" href="#Electric-field">Electric field</a><a id="Electric-field-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-field" title="Permalink"></a></h2><p>The electric field can be calculated as a function of position within the layered structure using the <code>electric_field()</code> function, which takes the <code>Structure</code> and desired wavelength <code>λ</code>, as well as optional argument angle of incidence <code>θ</code> and optional keyword argument for the number of data points <code>numpoints</code>. We can plot the field profile for the <a href="https://www.rp-photonics.com/bragg_mirrors.html">distributed bragg reflector</a> (DBR) we constructed in the previous section. Let&#39;s do this for <code>λ</code> = 1 μm.</p><pre><code class="language-julia hljs">λ_field = 1e-6
field = electric_field(s, λ_field)

f = Figure()
ax = Axis(f[1, 1], title = &quot;Electric Field Profile at λ = $(Int(λ_field * 1e9)) nm&quot;, xlabel = &quot;z position (nm)&quot;, ylabel = &quot;Field intensity (a.u.)&quot;)

lines!(field.z .* 1e9, real(field.p[1, :]).^2)
vlines!(field.boundaries[1], color = :gray30, linestyle = :dash)
vlines!(field.boundaries[end] * 1e9, color = :gray30, linestyle = :dash)

f</code></pre><img src="11600909.png" alt="Example block output"/><p>The electric field result contains the position <code>z</code> within the structure, the (x, y, z) components (corresponding to the first, second, and third components of the Array) of the p-polarized and s-polarized light, and the positions of the layer interfaces. So for example, to get the x-component of the p-polarized field along all of <code>z</code>, we would call <code>field.p[1, :]</code>, as we have done above.</p><p>The layer <code>boundaries</code> is useful for plotting (as shown in the figure above) and checking that the in-plane components are continuous throughout the structure, as required by <a href="https://en.wikipedia.org/wiki/Interface_conditions_for_electromagnetic_fields">Maxwell&#39;s interface conditions</a>.</p><h3 id="Minor-implementation-details"><a class="docs-heading-anchor" href="#Minor-implementation-details">Minor implementation details</a><a id="Minor-implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Minor-implementation-details" title="Permalink"></a></h3><p>Behind the scenes of the electric field calculation, a new <code>Structure</code> is actually being created and initialized for the user-supplied wavelength. The transfer matrix is again calculated for the provided wavelength and light incidence angle. Some solution of this sort is necessary because the <em>exact</em> wavelength that you may wish to calculate for may not be part of the original <code>Structure</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick Start</a><a class="docs-footer-nextpage" href="../../lib/public/">Public »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 11 January 2024 09:27">Thursday 11 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
