<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · TransferMatrix.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TransferMatrix.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#A-simple-calculation"><span>A simple calculation</span></a></li><li><a class="tocitem" href="#Defining-a-Layer"><span>Defining a Layer</span></a></li><li><a class="tocitem" href="#A-simple-multi-layered-structure"><span>A simple multi-layered structure</span></a></li><li><a class="tocitem" href="#Periodic-structures-with-a-YAML-config-file"><span>Periodic structures with a YAML config file</span></a></li><li><a class="tocitem" href="#Electric-field"><span>Electric field</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/garrekstemo/TransferMatrix.jl/blob/main/docs/src/guide/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>TransferMatrix.jl is not a part of Julia&#39;s general registry, but can be found at <a href="https://github.com/garrekstemo/TransferMatrix.jl">https://github.com/garrekstemo/TransferMatrix.jl</a>. Julia makes it easy to  install unregistered packages. From the <a href="https://docs.julialang.org/en/v1/stdlib/REPL/">Julia REPL</a>, enter the Pkg REPL (package manager) mode by typing <code>]</code> and then use <code>add</code> to add the GitHub URL to TransferMatrix.jl.</p><pre><code class="nohighlight hljs">pkg&gt; add https://github.com/garrekstemo/TransferMatrix.jl</code></pre><h2 id="A-simple-calculation"><a class="docs-heading-anchor" href="#A-simple-calculation">A simple calculation</a><a id="A-simple-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-calculation" title="Permalink"></a></h2><p>To get you up and running, let&#39;s build a simple two-layer structure of air and glass and calculate the reflectance and transmittance spectrum while changing the angle of incidence for the incoming electromagnetic field. It is just as simple to fix the incidence angle and calculate the transfer matrix as a function of the field wavelength.</p><p>We start by making a <code>Layer</code> type of air and a <code>Layer</code> of glass. We&#39;ll do this for  a wavelength of 1 μm. Since there are only two layers and the transfer matrix method treats the first and last layers as semi-infinite, there is no need to provide a thickness for our glass and air layers. From the examples below, you can see that there are fields for</p><ul><li>the material name</li><li>the layer thickness</li><li>a list of wavelengths</li><li>the real part of the refractive index (corresponding to the wavelength)</li><li>the imaginary part of the refractive index</li></ul><p>Details about different ways to make a layer are further on in the tutorial.</p><pre><code class="language-julia hljs">using TransferMatrix

air = Layer(&quot;Air&quot;, 0.0, [1.0e-6], [1.0], [0.0])
glass = Layer(&quot;Glass&quot;, 0.0, [1.0e-6], [1.5], [0.0])</code></pre><h3 id="Assembling-layers-into-a-structure"><a class="docs-heading-anchor" href="#Assembling-layers-into-a-structure">Assembling layers into a structure</a><a id="Assembling-layers-into-a-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-layers-into-a-structure" title="Permalink"></a></h3><p>Now that we have our glass and air layers, we need to assemble them into a structure and provide the angles of the field with respect to the surface of the structure. We do this with the <code>Structure</code> type.</p><pre><code class="language-julia hljs">θs = collect(range(0., 80., length = 500)) .* π/180
s = Structure([air, glass], [1.0e-6], θs)</code></pre><p>The first argument is just a list of layers. The second argument is a list of desired wavelengths. Often the refractive index data we have for  two materials are not given for exactly the same wavelengths.  TransferMatrix.jl uses an interpolation function to normalize the wavelengths and complex refractive indices for all layers from  this user-provided list of wavelengths. (Be careful if the range you provide goes beyond the range of the data that you have!) Now we can evaluate the angle-resolved spectrum using the function <code>angle_resolved()</code>.</p><pre><code class="language-julia hljs">res = angle_resolved(s)</code></pre><p>Let&#39;s also plot the result using the <a href="https://makie.juliaplots.org/">Makie.jl</a> data visualization package.</p><pre><code class="language-julia hljs">using CairoMakie

f = Figure()
ax = Axis(f[1, 1], xlabel = &quot;Incidence Angle (°)&quot;, ylabel = &quot;Reflectance / Transmittance&quot;)

lines!(s.θ .* 180/π, res.Rss[:, 1], color = :dodgerblue4, label = &quot;Rss&quot;)
lines!(s.θ .* 180/π, res.Rpp[:, 1], color = :dodgerblue1, label = &quot;Rpp&quot;)
lines!(s.θ .* 180/π, res.Tss[:, 1], color = :firebrick4, label = &quot;Tss&quot;)
lines!(s.θ .* 180/π, res.Tpp[:, 1], color = :orangered3, label = &quot;Tpp&quot;)

axislegend(ax)

f</code></pre><p align="center">
    <img src="../assets/air-glass_example.svg">
</p><p>We can see that the result of the angle-resolved calculation is Julia type with four solutions: the s-wave and p-wave for both the reflected and transmitted waves. Simultaneous calculation of s- and p- incident waves is a feature of the  general 4x4 transfer matrix method being used. The <code>angle_resolved</code> function will also loop through all wavelengths provided so that you can plot a heatmap of wavelength and angle versus transmittance (or reflectance).</p><h2 id="Defining-a-Layer"><a class="docs-heading-anchor" href="#Defining-a-Layer">Defining a Layer</a><a id="Defining-a-Layer-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Layer" title="Permalink"></a></h2><p>The <code>Layer</code> type is immutable. Once you make one, you can&#39;t change any of its  characteristics later. There are two ways to define a <code>Layer</code>. The first is by  directly filling in the argument fields:</p><pre><code class="language-julia hljs">Layer(material, thickness, λs, ns, κs)</code></pre><p>You may choose any units you like for thickness and wavelength,  but they must be the same (e.g. both are in nanometers). The material is just a <code>String</code>. Wavelength, and the  refractive index arguments must be Arrays, even if they just contain  with a single item. A very manual way to make a <code>Layer</code> might look like this:</p><pre><code class="language-julia hljs">glass = Layer(&quot;Glass&quot;, 20.0e-6, [1.0e-6, 1.1e-6, 1.3e-6], [0.0, 0.0, 0.0])</code></pre><p>This way works well for simple <code>Layers</code> or when you just need a single frequency for an angle-resolved calculation, but this is a lot more work if the refractive index  is pulled from a database or a file. The website <a href="https://refractiveindex.info">refractiveindex.info</a> contains a large database of refractive indices from peer-reviewed papers. TransferMatrix.jl makes it easy to use a CSV file downloaded from this website with the <code>read_refractive()</code> function, which returns a <code>Layer</code> type. You can choose  to include (or not) the real/imaginary part of the complex refractive index. Note that  this refractiveindex.info stores wavelength information in units of micrometers.</p><pre><code class="language-julia hljs">glass = read_refractive(&quot;/path/to/file.csv&quot;, &quot;Glass&quot;, 20e-6, div=1e6)</code></pre><p>The <code>div</code> keyword argument at the end of <code>read_refractive</code> represents the  desired unit conversion. In this case, if we want everything to be in meters we must divide each wavelength in the raw data by <span>$10^6$</span>. Alternatively, we can  change the thickness units to micrometers. Just be careful that all <code>Layer</code>s in your multi-layered structure have consistent units.</p><p>The <code>Layer</code> properties can be independently queried. To get the material name or thickness,  for example, you can just type:</p><pre><code class="language-julia hljs">julia&gt; glass.material
&quot;Glass&quot;
julia&gt; glass.thickness
2.0e-5</code></pre><p>The same can be done to get wavelengths (<code>glass.λ</code>) (get λ by typing <code>\lambda</code>), real refractive index (<code>glass.n</code>), and complex refractive index (<code>glass.κ</code>) (get κ by typing <code>\kappa</code>). (A very useful feature of Julia is built-in support for unicode characters).</p><h2 id="A-simple-multi-layered-structure"><a class="docs-heading-anchor" href="#A-simple-multi-layered-structure">A simple multi-layered structure</a><a id="A-simple-multi-layered-structure-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-multi-layered-structure" title="Permalink"></a></h2><p>Now that we can make <code>Layer</code>s, we can put them together to calculate  the transfer matrix for a multi-layered structure and plot the reflectance and transmittance spectra. A very important structure in optics is the Fabry-Pérot etalon, which can be made with two mirrors that face each other with a gap between them. Let&#39;s make this a  little more challenging (and experimentally realistic) by  mounting the mirrors onto windows that are transparent in our chosen wavelength range. The gap will simply be 20 μm of air. We will scan in the mid infrared between 4 and 6 μm and use data generated via the <a href="https://en.wikipedia.org/wiki/Lorentz_oscillator_model">Lorentz-Drude model</a> for each 10 nm-thick gold layer and experimental data from Malitson, 1963 for the windows.</p><pre><code class="language-julia hljs">λs = range(4.0, 6.0, length = 1000) .* 1e-6
aufile = abspath(&quot;./refractive_index_data/Au_nk_0.248-6.20um_Lorentz-Drude_Rakic1998.csv&quot;)
caf2file = abspath(&quot;./refractive_index_data/CaF2_n_0.23-9.7um_Malitson.csv&quot;)

air = Layer(&quot;Air&quot;, 20e-6, collect(λs), fill(1.0, length(λs)), zeros(length(λs)))
au = read_refractive(aufile, &quot;Au&quot;, 10e-9, div=1e6)
caf2 = read_refractive(caf2file, &quot;CaF2&quot;, 5.0e-6, div=1e6)

s = Structure([caf2, au, air, au, caf2], collect(λs), [0.0])
Tpp, Tss, Rpp, Rss = calculate_tr(s)</code></pre><p align="center">
    <img src="../assets/fabry-perot_example.svg">
</p><p>It is easy to combine manually-generated data and experimental data to calculate the global transfer matrix.</p><h2 id="Periodic-structures-with-a-YAML-config-file"><a class="docs-heading-anchor" href="#Periodic-structures-with-a-YAML-config-file">Periodic structures with a YAML config file</a><a id="Periodic-structures-with-a-YAML-config-file-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-structures-with-a-YAML-config-file" title="Permalink"></a></h2><p>With the tools described above, it is pretty easy to make any kind of multi-layered structure that you want. A very large structure, maybe one with repeating layers, is also not difficult to build. However, it would be useful to be able to load a  structure from a set of parameters so that it can be saved or even shared with others for better reproducibility. To do this, a <code>Structure</code> can be loaded directly from a YAML file (using <a href="https://github.com/JuliaData/YAML.jl">YAML.jl</a>). </p><p>Let&#39;s demonstrate this with a <a href="https://en.wikipedia.org/wiki/Distributed_Bragg_reflector">quarter-wave stack</a>, which is a periodic structure with two alternative layers where the thickness is one fourth of the wavelength within the medium, or the relation</p><p class="math-container">\[d_i = \frac{\lambda}{4n_i},\]</p><p>where <span>$d_i$</span> is the thickness for layer <span>$i$</span>, <span>$\lambda$</span> is the electric field wavelength in vacuum, and <span>$n_i$</span> is the index of refraction for layer <span>$i$</span>.</p><p>Here is the YAML file that gives us this:</p><pre><code class="nohighlight hljs"># All units in micrometers

min_wavelength: 0.5
max_wavelength: 2.0
n_wavelengths: 1000

# Theta in radians
theta_i: 0.0
theta_f: 0.0
n_theta: 1

layers:

    layer1:
        material: Air
        thickness: 0.5
        wavelength: 1.0
        refractive_index: 1.0
        extinction_coeff: 0.0

    layer2:
        periods: 3
        layers:
          layer1:
            material: &quot;ZnS n=2.32&quot;
            thickness: 0.1077
            refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv
          layer2:
            material: &quot;MgF2 n=1.36&quot;
            thickness: 0.1838
            refractive_filename: MgF2_nk_0.03-2.0um_Rodriguez2017.csv

    layer3: 
        material: &quot;ZnS n=2.32&quot;
        thickness: 0.1838
        refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv</code></pre><p>At the top, we set the minimum and maximum wavelengths to be calculated, with the  total number of points set to 1000. We won&#39;t do an angle-resolved calculation, so initial and final <span>$\theta$</span> are zero (with <code>n_theta</code> just one). Next the multi-layered structure is defined under <code>layers:</code>. The first layer is just air, so we don&#39;t need a file for this and can set the refractive index for a single wavelength. These values and wavelength are expanded when the YAML file is loaded. The final layer (<code>layer3</code>) is zinc sulfide (ZnS), which is loaded from a CSV file downloaded from <a href="https://refractiveindex.info">refractiveindex.info</a>. The middle section (<code>layer2</code>) is where we define the periodic structure. The first item determines how many periods we want. In this case, <code>periods: 3</code>. Then we  set the layers that alternate under another <code>layers</code> section. You can see that the first layer <code>layer1</code> is zinc sulfide and the second layer <code>layer2</code> is magnesium fluoride (MgF₂). The number of times that these two layers are repeated can easily be changed by editing the <code>periods</code> field. You can even have multiple repeating structures within the global structure for arbitrarily complicated structures.</p><p>To load the YAML config file into a <code>Structure</code>, we use the <code>load_from_yaml()</code> function. You can find this example in the <code>default_config</code> folder in the <code>quarter-wave.yaml</code> file.</p><pre><code class="language-julia hljs">s = load_from_yaml(&quot;.../default_config/quarter-wave.yaml&quot;)
Tpp, Tss, Rpp, Rss = calculate_tr(s)</code></pre><p>This particular example is taken from Pochi Yeh&#39;s <a href="https://www.wiley.com/en-us/Optical+Waves+in+Layered+Media-p-9780471731924"><em>Optical Waves in Layered Media</em></a> on page 110. You can find the reflectivity of this structure in Table 5.1. The values we have calculated are slightly different since the data used here is slightly dispersive with wavelength, but the example in the book takes flat refractive index values. You can try plotting this structure for an increasing number of periods and observe how the reflectance near <span>$\lambda$</span> = 1 μm increases.</p><pre><code class="language-julia hljs">using CairoMakie

f = Figure()
ax = Axis(f[1, 1], title = &quot;ZnS / MgF quarter-wave with 3 layers&quot;, xlabel = &quot;Wavelength (nm)&quot;, ylabel = &quot;Transmittance / Reflectance&quot;)

lines!(s.λ .* 1e9, Tpp, label = &quot;T&quot;)
lines!(s.λ .* 1e9, Rpp, label = &quot;R&quot;)
axislegend(ax, position = :rc)

f</code></pre><p align = "center">
    <img src = "../assets/quarter-wave_example.svg">
</p><h2 id="Electric-field"><a class="docs-heading-anchor" href="#Electric-field">Electric field</a><a id="Electric-field-1"></a><a class="docs-heading-anchor-permalink" href="#Electric-field" title="Permalink"></a></h2><p>The electric field can be calculated as a function of position within the layered structure using the <code>electric_field()</code> function, which takes the <code>Structure</code> and desired wavelength <code>λ</code>, as well as optional argument angle of incidence <code>θ</code> and optional keyword argument for the number of data points <code>numpoints</code>. We can plot the field profile for the <a href="https://www.rp-photonics.com/bragg_mirrors.html">distributed bragg reflector</a> (DBR) we constructed in the previous section. Let&#39;s do this for <code>λ</code> = 1 μm.</p><pre><code class="language-julia hljs">λ_field = 1e-6
field = electric_field(s, λ_field)

f = Figure()
ax = Axis(f[1, 1], title = &quot;Electric Field Profile at λ = $(Int(λ_field * 1e9)) nm&quot;, xlabel = &quot;z position (nm)&quot;, ylabel = &quot;Field intensity (a.u.)&quot;)

lines!(field.z .* 1e9, real(field.p[1, :]).^2)

vlines!(field.boundaries[1], color = :black)
vlines!(field.boundaries[end] * 1e9, color = :black)

f</code></pre><p align = "center">
    <img src = "../assets/dbr-field_example.svg">
</p><p>The electric field result contains the position <code>z</code> within the structure, the (x, y, z) components (corresponding to the first, second, and third components of the Array) of the p-polarized and s-polarized light, and the positions of the layer interfaces. So for example, to get the x-component of the p-polarized field along all of <code>z</code>, we would call <code>field.p[1, :]</code>, as we have done above.</p><p>The layer <code>boundaries</code> is useful for plotting (as shown in the figure above) and checking that the in-plane components are continuous throughout the structure, as required by <a href="https://en.wikipedia.org/wiki/Interface_conditions_for_electromagnetic_fields">Maxwell&#39;s interface conditions</a>.</p><h3 id="Minor-implementation-details"><a class="docs-heading-anchor" href="#Minor-implementation-details">Minor implementation details</a><a id="Minor-implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Minor-implementation-details" title="Permalink"></a></h3><p>Behind the scenes of the electric field calculation, a new <code>Structure</code> is actually being created and initialized for the user-supplied wavelength. The transfer matrix is again calculated for the provided wavelength and light incidence angle. Some solution of this sort is necessary because the <em>exact</em> wavelength that you may wish to calculate for may not be part of the original <code>Structure</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick Start</a><a class="docs-footer-nextpage" href="../../lib/public/">Public »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 1 September 2022 06:35">Thursday 1 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
