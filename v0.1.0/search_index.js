var documenterSearchIndex = {"docs":
[{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Transfer-Matrix-Functions","page":"API Reference","title":"Transfer Matrix Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [TransferMatrix]\nPages = [\"functions.jl\"]\nPrivate = false","category":"page"},{"location":"reference/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [TransferMatrix]\nPages = [\"types.jl\"]\nPrivate = false","category":"page"},{"location":"reference/#TransferMatrix.Layer","page":"API Reference","title":"TransferMatrix.Layer","text":"Layer\n\nA Layer stores information about a single layer, including its material name, thickness, a list of electric field wavelengths, and the real and imaginary parts of the refractive index associated with these wavelengths.\n\nInitializing a Layer with no arguments makes a 1 μm thick layer of Air.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TransferMatrix.Structure","page":"API Reference","title":"TransferMatrix.Structure","text":"Structure\n\nThe Structure is a mutable type that stores a Vector of Layer types, along with a list of field wavelengths and incident angles to calculate on.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Data-Read/Write-Functions","page":"API Reference","title":"Data Read/Write Functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [TransferMatrix]\nPages = [\"dataio.jl\"]\nPrivate = false","category":"page"},{"location":"reference/#TransferMatrix.load_from_yaml","page":"API Reference","title":"TransferMatrix.load_from_yaml","text":"read_yaml(file::String)\n\nRead a yaml file with Structure parameters to perform transfer matrix calculations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TransferMatrix.read_refractive-Tuple{String, String, Any}","page":"API Reference","title":"TransferMatrix.read_refractive","text":"read_refractive(f::String, material::String, thickness; div=1.0, freq=false)\n\nReads a csv file from refractiveindex.info containing  a wavlength column in units of micrometers, and two refractive index columns, one for the real part and the other for the imaginary part.\n\nThe header names are:\n\n\"Wavelength, μm\", \"n\", \"k\"\n\nFor some reason, the wavelength column cannot be normalized (so as to be a valid Julia identifier) using normalizednames = true in CSV.File, so the header is skipped.\n\n\n\n\n\n","category":"method"},{"location":"bibliography/#References","page":"References","title":"References","text":"","category":"section"},{"location":"bibliography/","page":"References","title":"References","text":"All references used for writing TransferMatrix.jl.","category":"page"},{"location":"bibliography/","page":"References","title":"References","text":"[1] N. C. Passler, M. Jeannin, and A. Paarmann, Layer-Resolved Absorption of Light in Arbitrarily Anisotropic Heterostructures, Phys. Rev. B 101, 165425 (2020). \n[2] B. Garibello, N. Avilán, J. A. Galvis, and C. A. Herreño-Fierro, On the Singularity of the Yeh 4 × 4 Transfer Matrix Formalism, Journal of Modern Optics 67, 832 (2020). \n[3] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures: Erratum, J. Opt. Soc. Am. B 36, 3246 (2019). \n[4] N. C. Passler and A. Paarmann, Generalized 4 × 4 Matrix Formalism for Light Propagation in Anisotropic Stratified Media: Study of Surface Phonon Polaritons in Polar Dielectric Heterostructures, J. Opt. Soc. Am. B 34, 2128 (2017). \n[5] P. Yeh, Optical Waves in Layered Media (Wiley, 2005). [6] W. Xu, L. T. Wood, and T. D. Golding, Optical Degeneracies in Anisotropic Layered Media: Treatment of Singularities in a 4×4 Matrix Formalism, Phys. Rev. B 61, 1740 (2000). \n[7] Z.-M. Li, B. T. Sullivan, and R. R. Parsons, Use of the 4 × 4 Matrix Method in the Optics of Multilayer Magnetooptic Recording Media, Appl. Opt., AO 27, 1334 (1988). \n[8] P. Yeh, Electromagnetic Propagation in Birefringent Layered Media, J. Opt. Soc. Am. 69, 742 (1979). \n[9] D. W. Berreman, Optics in Stratified and Anisotropic Media: 4×4-Matrix Formulation, J. Opt. Soc. Am. 62, 502 (1972).","category":"page"},{"location":"#TransferMatrix.jl","page":"Introduction","title":"TransferMatrix.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TransferMatrix.jl provides a general 4x4 transfer matrix method for optical waves propagating in layered media implemented in Julia. The core is an electrodynamics simulation based on Pochi Yeh's 4x4 transfer matrix method. Recent corrections and improvements are incorporated to deal with singularities and numerical instabilities for some types of multi-layered structures. The algorithms implemented are based on the efforts of others and sources are cited both in the documentation and docstrings where appropriate. A comprehensive bibliography is also available as part of the documentation.","category":"page"},{"location":"#Why-make-another-transfer-matrix-program?","page":"Introduction","title":"Why make another transfer matrix program?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are a lot of transfer matrix programs out there. Many are proprietary and some are part of graduate theses and papers. The problem with the proprietary ones are that the source code cannot be examined  nor modified (and are not free). The problem with programs  written for papers are that they are rarely maintained, are not well documented, are not well tested, and are poorly organized. This makes it very difficult to use them. TransferMatrix.jl  solves these problems and provides the first transfer matrix algorithm available for Julia.","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. can be used without the TransferMatrix. qualifier after loading the TransferMatrix.jl package with using TransferMatrix) types and functions are considered part of the public API of the TransferMatrix.jl package. All of these objects are documented in this manual. If not, please open an issue. The advanced user is encouraged, however, to access the guts of TransferMatrix.jl and modify portions to achieve a desired outcome or test  a different approach to the algorithm. This implementation is as modular as possible to maximize flexibility; each function is as small as possible so that the user may easily change any step along the way in calculating the transfer matrix, relfection or transmission spectrum, electric field profile, etc.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Getting-started","page":"Tutorial","title":"Getting started","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TransferMatrix.jl is not a part of Julia's general registry, but can be found at https://github.com/garrekstemo/TransferMatrix.jl. Julia makes it easy to  install unregistered packages. From the Julia REPL, enter the Pkg REPL (package manager) mode by typing ] and then use add to add the GitHub URL to TransferMatrix.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pkg> add https://github.com/garrekstemo/TransferMatrix.jl","category":"page"},{"location":"tutorial/#A-simple-calculation","page":"Tutorial","title":"A simple calculation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To get you up and running, let's build a simple two-layer structure of air and glass and calculate the reflectance and transmittance spectrum while changing the angle of incidence for the incoming electromagnetic field. It is just as simple to fix the incidence angle and calculate the transfer matrix as a function of the field wavelength.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by making a Layer type of air and a Layer of glass. We'll do this for  a wavelength of 1 μm. Since there are only two layers and the transfer matrix method treats the first and last layers as semi-infinite, there is no need to provide a thickness for our glass and air layers. From the examples below, you can see that there are fields for","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the material name\nthe layer thickness\na list of wavelengths\nthe real part of the refractive index (corresponding to the wavelength)\nthe imaginary part of the refractive index","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Details about different ways to make a layer are further on in the tutorial.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TransferMatrix\n\nair = Layer(\"Air\", 0.0, [1.0e-6], [1.0], [0.0])\nglass = Layer(\"Glass\", 0.0, [1.0e-6], [1.5], [0.0])","category":"page"},{"location":"tutorial/#Assembling-layers-into-a-structure","page":"Tutorial","title":"Assembling layers into a structure","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have our glass and air layers, we need to assemble them into a structure and provide the angles of the field with respect to the surface of the structure. We do this with the Structure type.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"θs = collect(range(0., 80., length = 500)) .* π/180\ns = Structure([air, glass], [1.0e-6], θs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first argument is just a list of layers. The second argument is a list of desired wavelengths. Often the refractive index data we have for  two materials are not given for exactly the same wavelengths.  TransferMatrix.jl uses an interpolation function to normalize the wavelengths and complex refractive indices for all layers from  this user-provided list of wavelengths. (Be careful if the range you provide goes beyond the range of the data that you have!) Now we can evaluate the angle-resolved spectrum using the function angle_resolved().","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"res = angle_resolved(s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's also plot the result using the Makie.jl data visualization package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\nf = Figure()\nax = Axis(f[1, 1], xlabel = \"Incidence Angle (°)\", ylabel = \"Reflectance / Transmittance\")\n\nlines!(s.θ .* 180/π, res.Rss[:, 1], color = :dodgerblue4, label = \"Rss\")\nlines!(s.θ .* 180/π, res.Rpp[:, 1], color = :dodgerblue1, label = \"Rpp\")\nlines!(s.θ .* 180/π, res.Tss[:, 1], color = :firebrick4, label = \"Tss\")\nlines!(s.θ .* 180/π, res.Tpp[:, 1], color = :orangered3, label = \"Tpp\")\n\naxislegend(ax)\n\nf","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<p align=\"center\">\n    <img src=\"/assets/air-glass_example.svg\">\n</p>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can see that the result of the angle-resolved calculation is Julia type with four solutions: the s-wave and p-wave for both the reflected and transmitted waves. Simultaneous calculation of s- and p- incident waves is a feature of the  general 4x4 transfer matrix method being used. The angle_resolved function will also loop through all wavelengths provided so that you can plot a heatmap of wavelength and angle versus transmittance (or reflectance).","category":"page"},{"location":"tutorial/#Defining-a-Layer","page":"Tutorial","title":"Defining a Layer","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Layer type is immutable. Once you make one, you can't change any of its  characteristics later. There are two ways to define a Layer. The first is by  directly filling in the argument fields:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Layer(material, thickness, λs, ns, κs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You may choose any units you like for thickness and wavelength,  but they must be the same (e.g. both are in nanometers). The material is just a String. Wavelength, and the  refractive index arguments must be Arrays, even if they just contain  with a single item. A very manual way to make a Layer might look like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"glass = Layer(\"Glass\", 20.0e-6, [1.0e-6, 1.1e-6, 1.3e-6], [0.0, 0.0, 0.0])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This way works well for simple Layers or when you just need a single frequency for an angle-resolved calculation, but this is a lot more work if the refractive index  is pulled from a database or a file. The website refractiveindex.info contains a large database of refractive indices from peer-reviewed papers. TransferMatrix.jl makes it easy to use a CSV file downloaded from this website with the read_refractive() function, which returns a Layer type. You can choose  to include (or not) the real/imaginary part of the complex refractive index. Note that  this refractiveindex.info stores wavelength information in units of micrometers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"glass = read_refractive(\"/path/to/file.csv\", \"Glass\", 20e-6, div=1e6)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The div keyword argument at the end of read_refractive represents the  desired unit conversion. In this case, if we want everything to be in meters we must divide each wavelength in the raw data by 10^6. Alternatively, we can  change the thickness units to micrometers. Just be careful that all Layers in your multi-layered structure have consistent units.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Layer properties can be independently queried. To get the material name or thickness,  for example, you can just type:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> glass.material\n\"Glass\"\njulia> glass.thickness\n2.0e-5","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same can be done to get wavelengths (glass.λ) (get λ by typing \\lambda), real refractive index (glass.n), and complex refractive index (glass.κ) (get κ by typing \\kappa). (A very useful feature of Julia is built-in support for unicode characters).","category":"page"},{"location":"tutorial/#A-simple-multi-layered-structure","page":"Tutorial","title":"A simple multi-layered structure","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we can make Layers, we can put them together to calculate  the transfer matrix for a multi-layered structure and plot the reflectance and transmittance spectra. A very important structure in optics is the Fabry-Pérot etalon, which can be made with two mirrors that face each other with a gap between them. Let's make this a  little more challenging (and experimentally realistic) by  mounting the mirrors onto windows that are transparent in our chosen wavelength range. The gap will simply be 20 μm of air. We will scan in the mid infrared between 4 and 6 μm and use data generated via the Lorentz-Drude model for each 10 nm-thick gold layer and experimental data from Malitson, 1963 for the windows.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"λs = range(4.0, 6.0, length = 1000) .* 1e-6\naufile = abspath(\"./refractive_index_data/Au_nk_0.248-6.20um_Lorentz-Drude_Rakic1998.csv\")\ncaf2file = abspath(\"./refractive_index_data/CaF2_n_0.23-9.7um_Malitson.csv\")\n\nair = Layer(\"Air\", 20e-6, collect(λs), fill(1.0, length(λs)), zeros(length(λs)))\nau = read_refractive(aufile, \"Au\", 10e-9, div=1e6)\ncaf2 = read_refractive(caf2file, \"CaF2\", 5.0e-6, div=1e6)\n\ns = Structure([caf2, au, air, au, caf2], collect(λs), [0.0])\nTpp, Tss, Rpp, Rss = calculate_tr(s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<p align=\"center\">\n    <img src=\"/docs/src/assets/fabry-perot_example.png\">\n</p>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is easy to combine manually-generated data and experimental data to calculate the global transfer matrix.","category":"page"},{"location":"tutorial/#Periodic-structures-with-a-YAML-config-file","page":"Tutorial","title":"Periodic structures with a YAML config file","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With the tools described above, it is pretty easy to make any kind of multi-layered structure that you want. A very large structure, maybe one with repeating layers, is also not difficult to build. However, it would be useful to be able to load a  structure from a set of parameters so that it can be saved or even shared with others for better reproducibility. To do this, a Structure can be loaded directly from a YAML file (using YAML.jl). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's demonstrate this with a quarter-wave stack, which is a periodic structure with two alternative layers where the thickness is one fourth of the wavelength within the medium, or the relation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"d_i = fraclambda4n_i","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where d_i is the thickness for layer i, lambda is the electric field wavelength in vacuum, and n_i is the index of refraction for layer i.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is the YAML file that gives us this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# All units in micrometers\n\nmin_wavelength: 0.5\nmax_wavelength: 2.0\nn_wavelengths: 1000\n\n# Theta in radians\ntheta_i: 0.0\ntheta_f: 0.0\nn_theta: 1\n\nlayers:\n\n    layer1:\n        material: Air\n        thickness: 0.5\n        wavelength: 1.0\n        refractive_index: 1.0\n        extinction_coeff: 0.0\n\n    layer2:\n        periods: 3\n        layers:\n          layer1:\n            material: \"ZnS n=2.32\"\n            thickness: 0.1077\n            refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv\n          layer2:\n            material: \"MgF2 n=1.36\"\n            thickness: 0.1838\n            refractive_filename: MgF2_nk_0.03-2.0um_Rodriguez2017.csv\n\n    layer3: \n        material: \"ZnS n=2.32\"\n        thickness: 0.1838\n        refractive_filename: ZnS_n_0.4-14um_Amotchkina2020.csv","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At the top, we set the minimum and maximum wavelengths to be calculated, with the  total number of points set to 1000. We won't do an angle-resolved calculation, so initial and final theta are zero (with n_theta just one). Next the multi-layered structure is defined under layers:. The first layer is just air, so we don't need a file for this and can set the refractive index for a single wavelength. These values and wavelength are expanded when the YAML file is loaded. The final layer (layer3) is zinc sulfide (ZnS), which is loaded from a CSV file downloaded from refractiveindex.info. The middle section (layer2) is where we define the periodic structure. The first item determines how many periods we want. In this case, periods: 3. Then we  set the layers that alternate under another layers section. You can see that the first layer layer1 is zinc sulfide and the second layer layer2 is magnesium fluoride (MgF₂). The number of times that these two layers are repeated can easily be changed by editing the periods field. You can even have multiple repeating structures within the global structure for arbitrarily complicated structures.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To load the YAML config file into a Structure, we use the load_from_yaml() function. You can find this example in the default_config folder in the quarter-wave.yaml file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"s = load_from_yaml(\".../default_config/quarter-wave.yaml\")\nTpp, Tss, Rpp, Rss = calculate_tr(s)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This particular example is taken from Pochi Yeh's Optical Waves in Layered Media on page 110. You can find the reflectivity of this structure in Table 5.1. The values we have calculated are slightly different since the data used here is slightly dispersive with wavelength, but the example in the book takes flat refractive index values. You can try plotting this structure for an increasing number of periods and observe how the reflectance near lambda = 1 μm increases.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie\n\nf = Figure()\nax = Axis(f[1, 1], title = \"ZnS / MgF quarter-wave with 3 layers\", xlabel = \"Wavelength (nm)\", ylabel = \"Transmittance / Reflectance\")\n\nlines!(s.λ .* 1e9, Tpp, label = \"T\")\nlines!(s.λ .* 1e9, Rpp, label = \"R\")\naxislegend(ax, position = :rc)\n\nf","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<p align = \"center\">\n    <img src = \"/assets/quarter-wave_example.svg\">\n</p>","category":"page"},{"location":"tutorial/#Electric-field","page":"Tutorial","title":"Electric field","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The electric field can be calculated as a function of position within the layered structure using the electric_field() function, which takes the Structure and desired wavelength λ, as well as optional argument angle of incidence θ and optional keyword argument for the number of data points numpoints. We can plot the field profile for the distributed bragg reflector (DBR) we constructed in the previous section. Let's do this for λ = 1 μm.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"λ_field = 1e-6\nfield = electric_field(s, λ_field)\n\nf = Figure()\nax = Axis(f[1, 1], title = \"Electric Field Profile at λ = $(Int(λ_field * 1e9)) nm\", xlabel = \"z position (nm)\", ylabel = \"Field intensity (a.u.)\")\n\nlines!(field.z .* 1e9, real(field.p[1, :]).^2)\n\nvlines!(field.boundaries[1], color = :black)\nvlines!(field.boundaries[end] * 1e9, color = :black)\n\nf","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<p align = \"center\">\n    <img src = \"/assets/dbr-field_example.svg\">\n</p>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The electric field result contains the position z within the structure, the (x, y, z) components (corresponding to the first, second, and third components of the Array) of the p-polarized and s-polarized light, and the positions of the layer interfaces. So for example, to get the x-component of the p-polarized field along all of z, we would call field.p[1, :], as we have done above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The layer boundaries is useful for plotting (as shown in the figure above) and checking that the in-plane components are continuous throughout the structure, as required by Maxwell's interface conditions.","category":"page"},{"location":"tutorial/#Minor-implementation-details","page":"Tutorial","title":"Minor implementation details","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Behind the scenes, a new Structure is actually being created and initialized for the user-supplied wavelength. The transfer matrix is again calculated for the provided wavelength and light incidence angle. Some solution of this sort is necessary because the exact wavelength that you may wish to calculate for may not be part of the original Structure.","category":"page"}]
}
